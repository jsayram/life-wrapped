// =============================================================================
// ContentView ‚Äî Main app interface
// =============================================================================

import SwiftUI
import SharedModels
import Charts
import Transcription
import Storage
import Summarization
import Security

// Note: Extensions, KeychainHelper, WordAnalyzer, and WiggleModifier are now in App/Helpers/

// MARK: - AppTheme

/// Apple Intelligence-inspired design system with purple/blue/magenta/green color palette
/// 
/// WCAG Compliance: All colors meet WCAG AA standards when used appropriately:
/// - darkPurple, magenta, emerald: Suitable for text on white (‚â•4.5:1)
/// - purple, skyBlue: Suitable for large text/icons on white (‚â•3:1), meets AA for dark backgrounds
/// - lightPurple: Background/border use only, not for text content
/// 
/// Usage Guidelines:
/// - Use darkPurple/magenta for body text and important labels
/// - Use purple/skyBlue for buttons, icons, and accents
/// - Use lightPurple only for decorative backgrounds and borders
/// - All text uses system .primary/.secondary colors; theme colors are for accents only
struct AppTheme {
    // MARK: - Core Colors
    
    /// Dark purple - Primary accent for active states
    /// Contrast: White 7.8:1 (AAA) | Black 2.7:1
    /// Usage: Text, buttons, active states
    static let darkPurple = Color(hex: "#6D28D9")
    
    /// Medium purple - Secondary accent for buttons and highlights
    /// Contrast: White 5.2:1 (AA) | Black 4.0:1
    /// Usage: Icons, tints, large text
    static let purple = Color(hex: "#8B5CF6")
    
    /// Light purple - Tertiary accent for backgrounds and borders
    /// Contrast: White 2.1:1 | Black 10.0:1 (AAA)
    /// Usage: Backgrounds, borders (never for text)
    static let lightPurple = Color(hex: "#C4B5FD")
    
    /// Sky blue - Cool accent for info states
    /// Contrast: White 3.8:1 | Black 5.5:1 (AA)
    /// Usage: Icons, info badges, dark mode text
    static let skyBlue = Color(hex: "#60A5FA")
    
    /// Pale blue - Subtle backgrounds
    /// Contrast: White 1.4:1 | Black 15.0:1 (AAA)
    /// Usage: Backgrounds only (never for text)
    static let paleBlue = Color(hex: "#DBEAFE")
    
    /// Magenta - Energetic accent for recording states
    /// Contrast: White 4.9:1 (AA) | Black 4.3:1
    /// Usage: Text, recording badges, active states
    static let magenta = Color(hex: "#EC4899")
    
    /// Emerald - Success states
    /// Contrast: White 4.5:1 (AA) | Black 4.7:1 (AA)
    /// Usage: Success text, checkmarks, status badges
    static let emerald = Color(hex: "#10B981")
    
    // MARK: - Card Overlays (Environment-Aware)
    
    /// Subtle purple overlay for cards
    /// Light mode: 0.03 opacity | Dark mode: 0.05 opacity
    static func cardGradient(for colorScheme: ColorScheme) -> some ShapeStyle {
        let opacity = colorScheme == .light ? 0.03 : 0.05
        return RadialGradient(
            colors: [
                purple.opacity(opacity),
                darkPurple.opacity(opacity * 0.5),
                Color.clear
            ],
            center: .center,
            startRadius: 50,
            endRadius: 200
        )
    }
    
    // MARK: - Icon Backgrounds
    
    /// Light purple background for icon-only buttons
    static let purpleIconBackground = purple.opacity(0.1)
}

// MARK: - ContentView

struct ContentView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var selectedTab = 0
    
    init() {
        print("üñºÔ∏è [ContentView] Initializing ContentView")
    }
    
    var body: some View {
        Group {
            if coordinator.isInitialized {
                TabView(selection: $selectedTab) {
                    HomeTab()
                        .tabItem {
                            Label("Home", systemImage: "house.fill")
                        }
                        .tag(0)

                    HistoryTab()
                        .tabItem {
                            Label("History", systemImage: "list.bullet")
                        }
                        .tag(1)

            OverviewTab()
                .tabItem {
                    Label("Overview", systemImage: "doc.text.fill")
                }
                .tag(2)

            SettingsTab()
                .tabItem {
                    Label("Settings", systemImage: "gear")
                }
                .tag(3)
                }
                .tint(AppTheme.purple)
            } else {
                // Show loading state while not initialized
                Color.clear
            }
        }
        .sheet(isPresented: $coordinator.needsPermissions) {
            PermissionsView()
                .environmentObject(coordinator)
                .interactiveDismissDisabled()
        }
        .toast($coordinator.currentToast)
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("SwitchToSettingsTab"))) { _ in
            selectedTab = 3
        }
        .overlay {
            if !coordinator.isInitialized && coordinator.initializationError == nil && !coordinator.needsPermissions {
                LoadingOverlay()
            }
        }
        .alert("Initialization Error", isPresented: .constant(coordinator.initializationError != nil)) {
            Button("Retry") {
                Task {
                    await coordinator.initialize()
                }
            }
        } message: {
            if let error = coordinator.initializationError {
                Text(error.localizedDescription)
            }
        }
    }
}

// MARK: - Home Tab

struct HomeTab: View {
    @EnvironmentObject var coordinator: AppCoordinator
    
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 16) {
                    // App Title - Centered and smaller
                    Text("Life Wrapped")
                        .font(Font.largeTitle.bold())
                        .fontWeight(.semibold)
                        .foregroundStyle(
                            LinearGradient(
                                colors: [AppTheme.purple, AppTheme.magenta],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .frame(maxWidth: .infinity)
                        .padding(.top, 8)
                    
                    // Streak Display - Minimal and transparent
                    StreakDisplay(streak: coordinator.currentStreak)
                    
                    // Recording Button
                    RecordingButton()
                    
                    Spacer()
                }
                .padding()
            }
            .refreshable {
                await refreshStats()
            }
            .navigationBarHidden(true)
        }
    }
    
    private func refreshStats() async {
        print("üîÑ [HomeTab] Manual refresh triggered")
        await coordinator.refreshTodayStats()
        await coordinator.refreshStreak()
        print("‚úÖ [HomeTab] Stats refreshed")
    }
}

// MARK: - History Tab

struct HistoryTab: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var sessions: [RecordingSession] = []
    @State private var sessionWordCounts: [UUID: Int] = [:]
    @State private var sessionHasSummary: [UUID: Bool] = [:]
    @State private var isLoading = true
    @State private var playbackError: String?
    @State private var searchText = ""
    @State private var showFavoritesOnly = false
    @State private var transcriptMatchingSessionIds: Set<UUID> = []
    @State private var isSearchingTranscripts = false
    @State private var searchDebounceTask: Task<Void, Never>?
    
    private var filteredSessions: [RecordingSession] {
        var result = sessions
        
        // Filter by favorites if enabled
        if showFavoritesOnly {
            result = result.filter { $0.isFavorite }
        }
        
        // Filter by search text
        if !searchText.isEmpty {
            let query = searchText.lowercased()
            let formatter = DateFormatter()
            formatter.dateStyle = .medium
            formatter.timeStyle = .short
            
            result = result.filter { session in
                // Search in title
                if let title = session.title, title.lowercased().contains(query) {
                    return true
                }
                // Search in notes
                if let notes = session.notes, notes.lowercased().contains(query) {
                    return true
                }
                // Search in date
                let dateString = formatter.string(from: session.startTime).lowercased()
                if dateString.contains(query) {
                    return true
                }
                // Search in transcripts (from cached results)
                return transcriptMatchingSessionIds.contains(session.sessionId)
            }
        }
        
        return result
    }
    
    var body: some View {
        NavigationStack {
            contentView
                .navigationTitle("History")
                .searchable(text: $searchText, prompt: "Search titles, notes, transcripts...")
                .onChange(of: searchText) { _, newValue in
                    // Debounce transcript search
                    searchDebounceTask?.cancel()
                    if newValue.count >= 2 {
                        searchDebounceTask = Task {
                            try? await Task.sleep(for: .milliseconds(300))
                            guard !Task.isCancelled else { return }
                            await searchTranscripts(query: newValue)
                        }
                    } else {
                        transcriptMatchingSessionIds = []
                    }
                }
                .toolbar {
                    ToolbarItem(placement: .topBarTrailing) {
                        HStack(spacing: 12) {
                            if isSearchingTranscripts {
                                ProgressView()
                                    .scaleEffect(0.7)
                            }
                            
                            Button {
                                showFavoritesOnly.toggle()
                            } label: {
                                Image(systemName: showFavoritesOnly ? "star.fill" : "star")
                                    .foregroundStyle(showFavoritesOnly ? .yellow : .secondary)
                            }
                        }
                    }
                }
                .task {
                    await loadSessions()
                }
                .refreshable {
                    await loadSessions()
                }
                .alert("Playback Error", isPresented: .constant(playbackError != nil)) {
                    Button("OK") {
                        playbackError = nil
                    }
                } message: {
                    if let error = playbackError {
                        Text(error)
                    }
                }
        }
    }
    
    @ViewBuilder
    private var contentView: some View {
        if isLoading {
            LoadingView(size: .medium)
        } else if sessions.isEmpty {
            ContentUnavailableView(
                "No Recordings Yet",
                systemImage: "mic.slash",
                description: Text("Tap the record button on the Home tab to start your first journal entry.")
            )
        } else if filteredSessions.isEmpty {
            ContentUnavailableView(
                "No Results",
                systemImage: "magnifyingglass",
                description: Text("No recordings match '\(searchText)'")
            )
        } else {
            sessionsList
        }
    }
    
    private var sessionsList: some View {
        List {
            // Stats summary at top
            if !searchText.isEmpty {
                Section {
                    Text("\(filteredSessions.count) recording\(filteredSessions.count == 1 ? "" : "s") found")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                }
            }
            
            ForEach(sortedDates, id: \.self) { date in
                Section {
                    ForEach(sessionsForDate(date), id: \.id) { session in
                        NavigationLink(destination: sessionDetailView(for: session)) {
                            SessionRowClean(
                                session: session,
                                wordCount: sessionWordCounts[session.sessionId],
                                hasSummary: sessionHasSummary[session.sessionId] ?? false
                            )
                        }
                    }
                    .onDelete { offsets in
                        deleteSession(at: offsets, in: date)
                    }
                } header: {
                    HStack {
                        Text(formatSectionDate(date))
                        Spacer()
                        Text("\(sessionsForDate(date).count) recording\(sessionsForDate(date).count == 1 ? "" : "s")")
                            .font(.caption)
                            .foregroundStyle(.tertiary)
                    }
                }
            }
        }
        .listStyle(.insetGrouped)
    }
    
    private func sessionDetailView(for session: RecordingSession) -> some View {
        SessionDetailView(session: session)
    }
    
    private func sessionsForDate(_ date: Date) -> [RecordingSession] {
        filteredSessions.filter { session in
            Calendar.current.isDate(session.startTime, inSameDayAs: date)
        }
    }
    
    /// Group sessions by date
    private var groupedSessions: [Date: [RecordingSession]] {
        Dictionary(grouping: filteredSessions) { session in
            Calendar.current.startOfDay(for: session.startTime)
        }
    }
    
    /// Sorted dates (most recent first)
    private var sortedDates: [Date] {
        Array(groupedSessions.keys).sorted(by: >)
    }
    
    private func formatSectionDate(_ date: Date) -> String {
        let calendar = Calendar.current
        if calendar.isDateInToday(date) {
            return "Today"
        } else if calendar.isDateInYesterday(date) {
            return "Yesterday"
        } else if calendar.isDate(date, equalTo: Date(), toGranularity: .weekOfYear) {
            let formatter = DateFormatter()
            formatter.dateFormat = "EEEE" // Day name like "Monday"
            return formatter.string(from: date)
        } else {
            let formatter = DateFormatter()
            formatter.dateStyle = .medium
            return formatter.string(from: date)
        }
    }
    
    private func loadSessions() async {
        isLoading = true
        do {
            sessions = try await coordinator.fetchRecentSessions(limit: 100)
            print("‚úÖ [HistoryTab] Loaded \(sessions.count) sessions")
            
            // Load word counts and summary status in parallel
            guard let dbManager = coordinator.getDatabaseManager() else { return }
            await withTaskGroup(of: (UUID, Int, Bool).self) { group in
                for session in sessions {
                    group.addTask {
                        let count = (try? await dbManager.fetchSessionWordCount(sessionId: session.sessionId)) ?? 0
                        let hasSummary = await ((try? dbManager.fetchSummaryForSession(sessionId: session.sessionId)) != nil)
                        return (session.sessionId, count, hasSummary)
                    }
                }
                
                for await (sessionId, wordCount, hasSummary) in group {
                    sessionWordCounts[sessionId] = wordCount
                    sessionHasSummary[sessionId] = hasSummary
                }
            }
        } catch {
            print("‚ùå [HistoryTab] Failed to load sessions: \(error)")
        }
        isLoading = false
    }
    
    private func searchTranscripts(query: String) async {
        guard query.count >= 2 else {
            transcriptMatchingSessionIds = []
            return
        }
        
        isSearchingTranscripts = true
        do {
            transcriptMatchingSessionIds = try await coordinator.searchSessionsByTranscript(query: query)
            print("üîç [HistoryTab] Found \(transcriptMatchingSessionIds.count) sessions matching '\(query)' in transcripts")
        } catch {
            print("‚ùå [HistoryTab] Transcript search failed: \(error)")
            transcriptMatchingSessionIds = []
        }
        isSearchingTranscripts = false
    }
    
    private func deleteSession(at offsets: IndexSet, in date: Date) {
        let sessionsForDate = self.sessionsForDate(date)
        
        Task {
            for index in offsets {
                let session = sessionsForDate[index]
                // Stop playback if any chunk from this session is playing
                for chunk in session.chunks {
                    if coordinator.audioPlayback.currentlyPlayingURL == chunk.fileURL {
                        coordinator.audioPlayback.stop()
                        break
                    }
                }
                do {
                    try await coordinator.deleteSession(session.sessionId)
                    sessions.removeAll { $0.sessionId == session.sessionId }
                    sessionWordCounts.removeValue(forKey: session.sessionId)
                    sessionHasSummary.removeValue(forKey: session.sessionId)
                } catch {
                    print("Failed to delete session: \(error)")
                }
            }
        }
    }
}

// MARK: - Overview Tab

struct OverviewTab: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @Environment(\.colorScheme) var colorScheme
    @State private var periodSummary: Summary?
    @State private var sessionCount: Int = 0
    @State private var sessionsInPeriod: [RecordingSession] = []
    @State private var yearWrapSummary: Summary?
    @State private var isWrappingUpYear = false
    @State private var isRegeneratingPeriodSummary = false
    @State private var isLoading = true
    @State private var selectedTimeRange: TimeRange = .allTime
    @State private var showYearWrapConfirmation = false
    
    // Session summaries for Today/Yesterday feed
    @State private var sessionSummaries: [Summary] = []
    // Period rollups for Week/Month/Year feed
    @State private var periodRollups: [Summary] = []
    

    
    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Time Range Picker - ALWAYS show so users can switch periods
                Picker("Time Range", selection: $selectedTimeRange) {
                    ForEach(TimeRange.allCases) { range in
                        Text(range.rawValue).tag(range)
                    }
                }
                .pickerStyle(.segmented)
                .tint(AppTheme.purple)
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .disabled(isLoading)
                
                // Content area
                Group {
                    if isLoading {
                        LoadingView(size: .medium)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                    } else if periodSummary == nil && sessionsInPeriod.isEmpty {
                        ContentUnavailableView(
                            "No Overview Yet",
                            systemImage: "doc.text",
                            description: Text("Record more journal entries to generate summaries.")
                        )
                    } else {
                        // Copy All button
                        if !sessionSummaries.isEmpty {
                            HStack {
                                Spacer()
                                Button {
                                    copyAllSummaries()
                                } label: {
                                    HStack(spacing: 6) {
                                        Image(systemName: "doc.on.doc")
                                            .font(.caption)
                                        Text("Copy \(sessionSummaries.count)")
                                            .font(.caption)
                                            .fontWeight(.medium)
                                    }
                                    .foregroundStyle(AppTheme.purple)
                                    .padding(.horizontal, 12)
                                    .padding(.vertical, 8)
                                    .background(
                                        RoundedRectangle(cornerRadius: 8)
                                            .fill(
                                                RadialGradient(
                                                    colors: [AppTheme.purple.opacity(0.15), AppTheme.purple.opacity(0.05)],
                                                    center: .center,
                                                    startRadius: 0,
                                                    endRadius: 40
                                                )
                                            )
                                    )
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 8)
                                            .stroke(
                                                LinearGradient(
                                                    colors: [AppTheme.purple.opacity(0.4), AppTheme.magenta.opacity(0.3)],
                                                    startPoint: .leading,
                                                    endPoint: .trailing
                                                ),
                                                lineWidth: 1.5
                                            )
                                    )
                                }
                            }
                            .padding(.horizontal, 16)
                            .padding(.top, 12)
                        }
                        
                        // New Feed Layout
                        ScrollView {
                            LazyVStack(spacing: 16) {
                                // Local period summary card for Today/Week/Month
                                if [.today, .week, .month].contains(selectedTimeRange) {
                                    if let periodSummary {
                                        PeriodSummaryCard(
                                            title: periodSummaryTitle(for: selectedTimeRange),
                                            subtitle: "Local AI rollup (on-device)",
                                            summary: periodSummary,
                                            isRegenerating: isRegeneratingPeriodSummary,
                                            onCopy: {
                                                UIPasteboard.general.string = periodSummary.text
                                                coordinator.showSuccess("Summary copied")
                                            },
                                            onRegenerate: {
                                                Task {
                                                    await regenerateAndReloadPeriodSummary()
                                                }
                                            }
                                        )
                                        .padding(.horizontal, 16)
                                        .padding(.top, 8)
                                    } else if !sessionsInPeriod.isEmpty {
                                        GeneratePeriodSummaryCard(
                                            title: periodSummaryTitle(for: selectedTimeRange),
                                            isGenerating: isRegeneratingPeriodSummary,
                                            onGenerate: {
                                                Task {
                                                    await regenerateAndReloadPeriodSummary()
                                                }
                                            }
                                        )
                                        .padding(.horizontal, 16)
                                        .padding(.top, 8)
                                    }
                                }
                                
                                // Year Wrapped Summary (only show for Year timerange)
                                if selectedTimeRange == .allTime {
                                    if let yearWrap = yearWrapSummary {
                                        YearWrappedCard(
                                            summary: yearWrap,
                                            coordinator: coordinator,
                                            onRegenerate: {
                                                showYearWrapConfirmation = true
                                            },
                                            isRegenerating: isWrappingUpYear
                                        )
                                        .padding(.horizontal, 16)
                                        .padding(.top, 8)
                                    } else if !sessionsInPeriod.isEmpty {
                                        // Show generate button if no Year Wrap exists
                                        GenerateYearWrapCard(
                                            onGenerate: {
                                                showYearWrapConfirmation = true
                                            },
                                            isGenerating: isWrappingUpYear
                                        )
                                        .padding(.horizontal, 16)
                                        .padding(.top, 8)
                                    }
                                }
                            }
                            
                            LazyVStack(spacing: 0, pinnedViews: [.sectionHeaders]) {
                                let timeBuckets = groupSessionsByTimeBucket()
                                
                                if timeBuckets.isEmpty {
                                    // No session summaries found
                                    ContentUnavailableView(
                                        "No Summaries Yet",
                                        systemImage: "doc.text",
                                        description: Text("Session summaries will appear here once recordings are summarized.")
                                    )
                                    .padding(.top, 60)
                                } else {
                                    ForEach(timeBuckets) { bucket in
                                        Section {
                                            if bucket.isEmpty {
                                                // Empty bucket - show grayed out message
                                                Text("No recordings")
                                                    .font(.caption)
                                                    .foregroundStyle(.tertiary)
                                                    .italic()
                                                    .frame(maxWidth: .infinity, alignment: .leading)
                                                    .padding(.horizontal, 16)
                                                    .padding(.vertical, 8)
                                            } else {
                                                // Summaries in this bucket
                                                ForEach(bucket.summaries) { summary in
                                                    SessionSummaryCard(summary: summary, coordinator: coordinator)
                                                        .padding(.horizontal, 16)
                                                        .padding(.vertical, 6)
                                                }
                                            }
                                        } header: {
                                            // Time bucket header
                                            HStack {
                                                Text(bucket.header)
                                                    .font(.headline)
                                                    .fontWeight(.semibold)
                                                    .foregroundStyle(bucket.isEmpty ? .secondary : .primary)
                                                
                                                Spacer()
                                                
                                                if !bucket.isEmpty {
                                                    Text("\(bucket.summaries.count)")
                                                        .font(.caption)
                                                        .fontWeight(.medium)
                                                        .foregroundStyle(.secondary)
                                                        .padding(.horizontal, 8)
                                                        .padding(.vertical, 4)
                                                        .background(
                                                            Capsule()
                                                                .fill(Color(.tertiarySystemFill))
                                                        )
                                                }
                                            }
                                            .padding(.horizontal, 16)
                                            .padding(.vertical, 12)
                                            .background(Color(.systemGroupedBackground))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            .background(Color(.systemGroupedBackground))
            .navigationTitle("Overview")
            .task {
                await loadInsights()
            }
            .refreshable {
                await loadInsights()
            }
            .onReceive(NotificationCenter.default.publisher(for: .periodSummariesUpdated)) { _ in
                Task {
                    await loadInsights()
                }
            }
            .onChange(of: selectedTimeRange) { oldValue, newValue in
                Task {
                    await loadInsights()
                }
            }
            .alert("Generate Year Wrap", isPresented: $showYearWrapConfirmation) {
                Button("Cancel", role: .cancel) { }
                Button(actionButtonTitle()) {
                    handleYearWrapAction()
                }
            } message: {
                Text(yearWrapMessage())
            }
        }
    }
    
    private func hasExternalAPIConfigured() -> Bool {
        let openaiKey = KeychainHelper.load(key: "openai_api_key")
        let anthropicKey = KeychainHelper.load(key: "anthropic_api_key")
        return (openaiKey != nil && !openaiKey!.isEmpty) || (anthropicKey != nil && !anthropicKey!.isEmpty)
    }
    
    private func yearWrapMessage() -> String {
        if hasExternalAPIConfigured() {
            return "This will use ChatGPT or Claude to analyze your entire year of recordings and create a comprehensive year-in-review summary.\n\nThis process may take 30-60 seconds."
        } else {
            return "To generate a Year Wrap, you need to configure your ChatGPT (OpenAI) or Claude (Anthropic) API key in Settings.\n\nTap 'Open Settings' to add your API credentials."
        }
    }
    
    private func actionButtonTitle() -> String {
        return hasExternalAPIConfigured() ? "Generate" : "Open Settings"
    }
    
    private func handleYearWrapAction() {
        if hasExternalAPIConfigured() {
            Task {
                await wrapUpYear(forceRegenerate: false)
            }
        } else {
            // Post notification to switch to Settings tab
            NotificationCenter.default.post(name: NSNotification.Name("SwitchToSettingsTab"), object: nil)
        }
    }
    
    private func loadInsights() async {
        isLoading = true
        do {
            // Get date range for filtering
            let dateRange = getDateRange(for: selectedTimeRange)
            
            // Load period summary based on selected time range
            let periodType: PeriodType = {
                switch selectedTimeRange {
                case .yesterday: return .day
                case .today: return .day
                case .week: return .week
                case .month: return .month
                case .allTime: return .year // Show yearly summary for current year
                }
            }()
            
            // Clear previous data to avoid stale counts when DB is unavailable
            sessionsInPeriod = []
            sessionCount = 0
            sessionSummaries = []
            periodRollups = []
            
            // Load sessions in this period first
            if let dbManager = coordinator.getDatabaseManager() {
                if selectedTimeRange == .today || selectedTimeRange == .yesterday {
                    sessionsInPeriod = (try? await dbManager.fetchSessionsByDate(date: dateRange.start)) ?? []
                } else {
                    // For week/month/all, fetch ALL sessions and filter by date range
                    let allSessions = try? await coordinator.fetchRecentSessions(limit: 10000)
                    sessionsInPeriod = allSessions?.filter { session in
                        session.startTime >= dateRange.start && session.startTime < dateRange.end
                    } ?? []
                }
                sessionCount = sessionsInPeriod.count
                
                // Load summaries based on time range
                switch selectedTimeRange {
                case .today, .yesterday:
                    // Load session summaries for individual sessions
                    sessionSummaries = (try? await dbManager.fetchSessionSummariesInDateRange(
                        from: dateRange.start,
                        to: dateRange.end
                    )) ?? []
                    print("‚úÖ [OverviewTab] Loaded \(sessionSummaries.count) session summaries")
                    
                case .week:
                    // Load weekly rollup summaries (one card per week)
                    periodRollups = (try? await dbManager.fetchWeeklySummaries(
                        from: dateRange.start,
                        to: dateRange.end
                    )) ?? []
                    print("‚úÖ [OverviewTab] Loaded \(periodRollups.count) weekly rollups")
                    
                case .month:
                    // Load monthly rollup summaries (one card per month)
                    periodRollups = (try? await dbManager.fetchMonthlySummaries(
                        from: dateRange.start,
                        to: dateRange.end
                    )) ?? []
                    print("‚úÖ [OverviewTab] Loaded \(periodRollups.count) monthly rollups")
                    
                case .allTime:
                    // Load yearly rollup summary (single card for whole year)
                    let allYearlySummaries = (try? await dbManager.fetchSummaries(periodType: .year)) ?? []
                    periodRollups = allYearlySummaries.filter { summary in
                        summary.periodStart >= dateRange.start && summary.periodStart < dateRange.end
                    }
                    print("‚úÖ [OverviewTab] Loaded \(periodRollups.count) yearly rollup")
                }
            }
            
            // Try to fetch existing period summary (don't auto-generate on view load)
            // For week/month/year, use Date() to get current period, for day use startDate
            let dateForFetch = (periodType == .day) ? dateRange.start : Date()
            periodSummary = try? await coordinator.fetchPeriodSummary(type: periodType, date: dateForFetch)

            if selectedTimeRange == .allTime {
                yearWrapSummary = try? await coordinator.fetchPeriodSummary(type: .yearWrap, date: dateForFetch)
            } else {
                yearWrapSummary = nil
            }
            
            // Debug logging
            if periodSummary == nil && !sessionsInPeriod.isEmpty {
                print("‚ÑπÔ∏è [OverviewTab] No \(periodType.rawValue) summary found for \(dateForFetch.formatted()), use Regenerate to create one")
                print("   Searched for: type=\(periodType.rawValue), date=\(dateForFetch.ISO8601Format())")
                print("   Sessions in period: \(sessionsInPeriod.count)")
            } else if periodSummary != nil {
                print("‚úÖ [OverviewTab] Found \(periodType.rawValue) summary for \(dateForFetch.formatted())")
            }
        } catch {
            print("‚ùå [OverviewTab] Failed to load insights: \(error)")
        }
        isLoading = false
    }
    
    private func regenerateAndReloadPeriodSummary() async {
        guard !isRegeneratingPeriodSummary else { return }
        isRegeneratingPeriodSummary = true
        defer { isRegeneratingPeriodSummary = false }
        await regeneratePeriodSummary()
        await loadInsights()
    }

    private func regeneratePeriodSummary() async {
        let (startDate, _) = getDateRange(for: selectedTimeRange)
        
        let periodType: PeriodType = {
            switch selectedTimeRange {
            case .yesterday: return .day
            case .today: return .day
            case .week: return .week
            case .month: return .month
            case .allTime: return .year
            }
        }()
        
        // Use Date() (today) for week/month/year calculations, startDate for day
        let dateForGeneration = (periodType == .day) ? startDate : Date()
        
        print("üîÑ [OverviewTab] Regenerating \(periodType.rawValue) summary...")
        
        switch periodType {
        case .day:
            await coordinator.updateDailySummary(date: dateForGeneration, forceRegenerate: false)
        case .week:
            await coordinator.updateWeeklySummary(date: dateForGeneration, forceRegenerate: false)
        case .month:
            await coordinator.updateMonthlySummary(date: dateForGeneration, forceRegenerate: false)
        case .year:
            await coordinator.updateYearlySummary(date: dateForGeneration, forceRegenerate: false)
        default:
            break
        }
        
        // Fetch again after regeneration
        try? await Task.sleep(nanoseconds: 500_000_000) // Wait 0.5s
        periodSummary = try? await coordinator.fetchPeriodSummary(type: periodType, date: dateForGeneration)
        
        if periodSummary != nil {
            coordinator.showSuccess("Summary regenerated")
        } else {
            coordinator.showError("Failed to regenerate summary")
        }
    }

    private func wrapUpYear(forceRegenerate: Bool) async {
        guard !isWrappingUpYear else { return }
        isWrappingUpYear = true
        let dateForGeneration = Date()

        await coordinator.wrapUpYear(date: dateForGeneration, forceRegenerate: forceRegenerate)

        yearWrapSummary = try? await coordinator.fetchPeriodSummary(type: .yearWrap, date: dateForGeneration)
        isWrappingUpYear = false
    }
    
    private func formatHour(_ hour: Int) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h a"
        let calendar = Calendar.current
        let date = calendar.date(bySettingHour: hour, minute: 0, second: 0, of: Date()) ?? Date()
        return formatter.string(from: date)
    }
    
    private func formatHourShort(_ hour: Int) -> String {
        if hour == 0 {
            return "12 AM"
        } else if hour < 12 {
            return "\(hour) AM"
        } else if hour == 12 {
            return "12 PM"
        } else {
            return "\(hour - 12) PM"
        }
    }
    
    private func formatDayOfWeek(_ dayOfWeek: Int) -> String {
        let days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        return days[dayOfWeek]
    }
    
    private func formatDayOfWeekFull(_ dayOfWeek: Int) -> String {
        let days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        return days[dayOfWeek]
    }
    
    private func getDateRange(for timeRange: TimeRange) -> (start: Date, end: Date) {
        let calendar = Calendar.current
        let now = Date()
        
        switch timeRange {
        case .yesterday:
            let yesterday = calendar.date(byAdding: .day, value: -1, to: now) ?? now
            let start = calendar.startOfDay(for: yesterday)
            // Use end-of-day so hourly buckets cover the full 24 hours
            let end = calendar.date(byAdding: DateComponents(day: 1, second: -1), to: start) ?? now
            return (start, end)
        case .today:
            let start = calendar.startOfDay(for: now)
            return (start, now)
        case .week:
            // Current week: Monday to Sunday (or today if mid-week)
            var components = calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: now)
            components.weekday = 2 // Monday
            let startOfWeek = calendar.date(from: components) ?? now
            return (startOfWeek, now)
        case .month:
            let start = calendar.date(byAdding: .month, value: -1, to: now) ?? now
            return (start, now)
        case .allTime:
            // Show only current year (e.g., 2025) up to today
            let currentYear = calendar.component(.year, from: now)
            let startOfYear = calendar.date(from: DateComponents(year: currentYear, month: 1, day: 1)) ?? now
            return (startOfYear, now)
        }
    }

    private func periodSummaryTitle(for range: TimeRange) -> String {
        switch range {
        case .today: return "Today's Recordings"
        case .week: return "This Week's Recordings"
        case .month: return "This Month's Recordings"
        default: return "Recordings"
        }
    }
    
    private func filterSession(_ session: (sessionId: UUID, duration: TimeInterval, date: Date)?, in range: (start: Date, end: Date)) -> (sessionId: UUID, duration: TimeInterval, date: Date)? {
        guard let session = session else { return nil }
        return session.date >= range.start && session.date <= range.end ? session : nil
    }
    
    private func filterMonth(_ month: (year: Int, month: Int, count: Int, sessionIds: [UUID])?, in range: (start: Date, end: Date)) -> (year: Int, month: Int, count: Int, sessionIds: [UUID])? {
        guard let month = month else { return nil }
        let calendar = Calendar.current
        guard let monthDate = calendar.date(from: DateComponents(year: month.year, month: month.month)) else { return nil }
        return monthDate >= range.start && monthDate <= range.end ? month : nil
    }
    
    private func filterSessionsByHour(_ sessions: [(hour: Int, count: Int, sessionIds: [UUID])], in range: (start: Date, end: Date)) async -> [(hour: Int, count: Int, sessionIds: [UUID])] {
        if range.start == Date.distantPast { return sessions }
        
        var filtered: [Int: [UUID]] = [:]
        
        for hourData in sessions {
            for sessionId in hourData.sessionIds {
                if let session = try? await coordinator.fetchSessions(ids: [sessionId]).first,
                   session.startTime >= range.start && session.startTime <= range.end {
                    filtered[hourData.hour, default: []].append(sessionId)
                }
            }
        }
        
        return filtered.map { (hour: $0.key, count: $0.value.count, sessionIds: $0.value) }
    }
    
    private func filterSessionsByDayOfWeek(_ sessions: [(dayOfWeek: Int, count: Int, sessionIds: [UUID])], in range: (start: Date, end: Date)) async -> [(dayOfWeek: Int, count: Int, sessionIds: [UUID])] {
        if range.start == Date.distantPast { return sessions }
        
        var filtered: [Int: [UUID]] = [:]
        
        for dayData in sessions {
            for sessionId in dayData.sessionIds {
                if let session = try? await coordinator.fetchSessions(ids: [sessionId]).first,
                   session.startTime >= range.start && session.startTime <= range.end {
                    filtered[dayData.dayOfWeek, default: []].append(sessionId)
                }
            }
        }
        
        return filtered.map { (dayOfWeek: $0.key, count: $0.value.count, sessionIds: $0.value) }
    }
    
    // MARK: - Time Bucketing for Feed View
    
    struct TimeBucket: Identifiable {
        let id = UUID()
        let header: String
        let summaries: [Summary]
        let isEmpty: Bool
    }
    
    private func groupSessionsByTimeBucket() -> [TimeBucket] {
        let calendar = Calendar.current
        let dateRange = getDateRange(for: selectedTimeRange)
        
        switch selectedTimeRange {
        case .today, .yesterday:
            // Show individual session summaries grouped by hour
            return groupByHour(dateRange: dateRange, calendar: calendar)
            
        case .week:
            // Show weekly rollup summaries (one card per week)
            return groupByWeekRollup(dateRange: dateRange, calendar: calendar, rollups: periodRollups)
            
        case .month:
            // Show monthly rollup summaries (one card per month)
            return groupByMonthRollup(dateRange: dateRange, calendar: calendar, rollups: periodRollups)
            
        case .allTime:
            // Show yearly rollup summary (single card for whole year)
            return groupByYearRollup(dateRange: dateRange, calendar: calendar, rollups: periodRollups)
        }
    }
    
    private func groupByHour(dateRange: (start: Date, end: Date), calendar: Calendar) -> [TimeBucket] {
        var buckets: [TimeBucket] = []
        var summariesByHour: [Int: [Summary]] = [:]
        
        // Group existing summaries by hour
        for summary in sessionSummaries {
            let hour = calendar.component(.hour, from: summary.periodStart)
            summariesByHour[hour, default: []].append(summary)
        }
        
        // Create buckets for all hours in range
        let startHour = calendar.component(.hour, from: dateRange.start)
        let endHour = calendar.component(.hour, from: dateRange.end)
        let actualEndHour = dateRange.end > dateRange.start ? endHour : 23
        
        for hour in startHour...actualEndHour {
            let hourString = hour == 0 ? "12 AM" : (hour < 12 ? "\(hour) AM" : (hour == 12 ? "12 PM" : "\(hour - 12) PM"))
            let nextHour = (hour + 1) % 24
            let nextHourString = nextHour == 0 ? "12 AM" : (nextHour < 12 ? "\(nextHour) AM" : (nextHour == 12 ? "12 PM" : "\(nextHour - 12) PM"))
            let header = "\(hourString) - \(nextHourString)"
            
            let summaries = summariesByHour[hour] ?? []
            buckets.append(TimeBucket(header: header, summaries: summaries, isEmpty: summaries.isEmpty))
        }
        
        return buckets.reversed() // Newest first (oldest at bottom)
    }
    
    private func groupByDayRollup(dateRange: (start: Date, end: Date), calendar: Calendar, rollups: [Summary]) -> [TimeBucket] {
        var buckets: [TimeBucket] = []
        
        var summariesByDay: [Date: [Summary]] = [:]
        for summary in rollups {
            let dayStart = calendar.startOfDay(for: summary.periodStart)
            summariesByDay[dayStart, default: []].append(summary)
        }
        
        // Create buckets for all days in range
        var currentDate = calendar.startOfDay(for: dateRange.start)
        let endDate = calendar.startOfDay(for: dateRange.end)
        
        while currentDate <= endDate {
            let formatter = DateFormatter()
            if calendar.isDateInToday(currentDate) {
                formatter.dateFormat = "'Today' - EEEE, MMM d"
            } else if calendar.isDateInYesterday(currentDate) {
                formatter.dateFormat = "'Yesterday' - EEEE, MMM d"
            } else {
                formatter.dateFormat = "EEEE, MMM d"
            }
            let header = formatter.string(from: currentDate)
            
            let summaries = summariesByDay[currentDate] ?? []
            buckets.append(TimeBucket(header: header, summaries: summaries, isEmpty: summaries.isEmpty))
            
            currentDate = calendar.date(byAdding: .day, value: 1, to: currentDate) ?? currentDate
        }
        
        return buckets.reversed() // Most recent first
    }
    
    private func groupByWeekRollup(dateRange: (start: Date, end: Date), calendar: Calendar, rollups: [Summary]) -> [TimeBucket] {
        var buckets: [TimeBucket] = []
        
        var summariesByWeek: [Date: [Summary]] = [:]
        for summary in rollups {
            let weekStart = calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: summary.periodStart)
            if let weekStartDate = calendar.date(from: weekStart) {
                summariesByWeek[weekStartDate, default: []].append(summary)
            }
        }
        
        // Create buckets for all weeks in range
        var currentWeekStart = calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: dateRange.start)
        let endWeekStart = calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: dateRange.end)
        
        guard var currentWeekDate = calendar.date(from: currentWeekStart),
              let endWeekDate = calendar.date(from: endWeekStart) else {
            return buckets
        }
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MMM d"
        
        while currentWeekDate <= endWeekDate {
            let weekEnd = calendar.date(byAdding: .day, value: 6, to: currentWeekDate) ?? currentWeekDate
            // Format: "Monday, Dec 16 - Sunday, Dec 22"
            let header = "Monday, \(dateFormatter.string(from: currentWeekDate)) - Sunday, \(dateFormatter.string(from: weekEnd))"
            
            let summaries = summariesByWeek[currentWeekDate] ?? []
            buckets.append(TimeBucket(header: header, summaries: summaries, isEmpty: summaries.isEmpty))
            
            currentWeekDate = calendar.date(byAdding: .weekOfYear, value: 1, to: currentWeekDate) ?? currentWeekDate
        }
        
        return buckets.reversed() // Most recent first
    }
    
    private func groupByMonthRollup(dateRange: (start: Date, end: Date), calendar: Calendar, rollups: [Summary]) -> [TimeBucket] {
        var buckets: [TimeBucket] = []
        
        var summariesByMonth: [Date: [Summary]] = [:]
        for summary in rollups {
            let monthStart = calendar.dateComponents([.year, .month], from: summary.periodStart)
            if let monthStartDate = calendar.date(from: monthStart) {
                summariesByMonth[monthStartDate, default: []].append(summary)
            }
        }
        
        // Create buckets for all months in range
        var currentMonthStart = calendar.dateComponents([.year, .month], from: dateRange.start)
        let endMonthStart = calendar.dateComponents([.year, .month], from: dateRange.end)
        
        guard var currentMonthDate = calendar.date(from: currentMonthStart),
              let endMonthDate = calendar.date(from: endMonthStart) else {
            return buckets
        }
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MMMM yyyy"
        
        while currentMonthDate <= endMonthDate {
            let header = dateFormatter.string(from: currentMonthDate)
            
            let summaries = summariesByMonth[currentMonthDate] ?? []
            buckets.append(TimeBucket(header: header, summaries: summaries, isEmpty: summaries.isEmpty))
            
            currentMonthDate = calendar.date(byAdding: .month, value: 1, to: currentMonthDate) ?? currentMonthDate
        }
        
        return buckets.reversed() // Most recent first
    }
    
    private func groupByYearRollup(dateRange: (start: Date, end: Date), calendar: Calendar, rollups: [Summary]) -> [TimeBucket] {
        var buckets: [TimeBucket] = []
        
        var summariesByYear: [Int: [Summary]] = [:]
        for summary in rollups {
            let year = calendar.component(.year, from: summary.periodStart)
            summariesByYear[year, default: []].append(summary)
        }
        
        // Create buckets for all years in range
        let startYear = calendar.component(.year, from: dateRange.start)
        let endYear = calendar.component(.year, from: dateRange.end)
        
        for year in startYear...endYear {
            let header = "\(year)"
            let summaries = summariesByYear[year] ?? []
            buckets.append(TimeBucket(header: header, summaries: summaries, isEmpty: summaries.isEmpty))
        }
        
        return buckets.reversed() // Most recent first
    }
    
    // MARK: - Copy All Functionality
    
    private func copyAllSummaries() {
        let timeBuckets = groupSessionsByTimeBucket()
        var fullText = ""
        
        for bucket in timeBuckets {
            if !bucket.summaries.isEmpty {
                // Add bucket header
                fullText += "\(bucket.header)\n"
                fullText += String(repeating: "=", count: bucket.header.count) + "\n\n"
                
                // Add each summary in the bucket
                for summary in bucket.summaries {
                    let dateFormatter = DateFormatter()
                    dateFormatter.dateFormat = "MMM d, yyyy 'at' h:mm a"
                    let timeString = dateFormatter.string(from: summary.periodStart)
                    
                    fullText += "‚Ä¢ \(timeString)\n"
                    fullText += summary.text + "\n\n"
                }
                
                fullText += "\n"
            }
        }
        
        if !fullText.isEmpty {
            UIPasteboard.general.string = fullText
            coordinator.showSuccess("All summaries copied to clipboard")
        } else {
            coordinator.showError("No summaries to copy")
        }
    }
    
    private func formatMonth(year: Int, month: Int) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM yyyy"
        let calendar = Calendar.current
        let date = calendar.date(from: DateComponents(year: year, month: month)) ?? Date()
        return formatter.string(from: date)
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let minutes = Int(duration) / 60
        let seconds = Int(duration) % 60
        if minutes > 0 {
            return "\(minutes)m \(seconds)s"
        } else {
            return "\(seconds)s"
        }
    }
    
    // MARK: - Word Cloud Styling Helpers
    
    private func fontSizeForRank(_ rank: Int) -> CGFloat {
        // Top words get larger fonts
        switch rank {
        case 0...2: return 22  // Top 3
        case 3...5: return 20  // 4-6
        case 6...9: return 18  // 7-10
        default: return 16     // 11-20
        }
    }
    
    private func colorForRank(_ rank: Int) -> Color {
        // Apple Intelligence gradient colors for word frequency
        switch rank {
        case 0...2: return AppTheme.darkPurple    // Top 3 - most frequent
        case 3...5: return AppTheme.purple        // 4-6
        case 6...9: return AppTheme.magenta       // 7-10
        case 10...14: return AppTheme.skyBlue     // 11-15
        default: return AppTheme.lightPurple      // 16-20
        }
    }
    
    // MARK: - Sentiment Helpers
    
    private func sentimentColor(_ score: Double) -> Color {
        switch score {
        case ..<(-0.3): return AppTheme.magenta  // Negative
        case -0.3..<0.3: return AppTheme.skyBlue  // Neutral
        default: return AppTheme.emerald         // Positive
        }
    }
    
    private func sentimentLabel(_ score: Double) -> String {
        switch score {
        case ..<(-0.5): return "üò¢"
        case -0.5..<(-0.2): return "üòî"
        case -0.2..<0.2: return "üòê"
        case 0.2..<0.5: return "üôÇ"
        default: return "üòä"
        }
    }
    
    @ViewBuilder
    private func sentimentStatBox(label: String, count: Int, color: Color) -> some View {
        VStack(spacing: 4) {
            Text("\(count)")
                .font(.title2)
                .fontWeight(.bold)
                .foregroundStyle(color)
            Text(label)
                .font(.caption)
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 8)
        .background(
            RadialGradient(
                colors: [color.opacity(0.15), color.opacity(0.05)],
                center: .center,
                startRadius: 0,
                endRadius: 50
            )
        )
        .clipShape(RoundedRectangle(cornerRadius: 8))
    }
    
    private func languageColor(index: Int) -> Color {
        let colors: [Color] = [
            AppTheme.skyBlue,
            AppTheme.emerald,
            AppTheme.magenta,
            AppTheme.darkPurple,
            AppTheme.purple,
            AppTheme.lightPurple,
            AppTheme.paleBlue
        ]
        return colors[index % colors.count]
    }
    
    private var periodTitle: String {
        switch selectedTimeRange {
        case .yesterday: return "Yesterday's Summary"
        case .today: return "Today's Summary"
        case .week: return "This Week's Summary"
        case .month: return "This Month's Summary"
        case .allTime:
            let calendar = Calendar.current
            let currentYear = calendar.component(.year, from: Date())
            return "\(currentYear) Summary"
        }
    }

    }

// MARK: - FilteredSessionsView

struct FilteredSessionsView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    let title: String
    let sessionIds: [UUID]
    
    @State private var sessions: [RecordingSession] = []
    @State private var sessionWordCounts: [UUID: Int] = [:]
    @State private var isLoading = true
    
    var body: some View {
        Group {
            if isLoading {
                ProgressView("Loading sessions...")
            } else if sessions.isEmpty {
                ContentUnavailableView(
                    "No Sessions",
                    systemImage: "waveform",
                    description: Text("No sessions found for this filter.")
                )
            } else {
                List {
                    ForEach(sessions, id: \.sessionId) { session in
                        NavigationLink {
                            SessionDetailView(session: session)
                        } label: {
                            VStack(alignment: .leading, spacing: 8) {
                                HStack {
                                    Text(session.startTime.formatted(date: .abbreviated, time: .shortened))
                                        .font(.headline)
                                    Spacer()
                                    if let wordCount = sessionWordCounts[session.sessionId] {
                                        Text("\(wordCount) words")
                                            .font(.caption)
                                            .foregroundStyle(.secondary)
                                    }
                                }
                                
                                HStack {
                                    Text("\(session.chunkCount) chunk\(session.chunkCount == 1 ? "" : "s")")
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                    Text("‚Ä¢")
                                        .foregroundStyle(.secondary)
                                    Text(formatDuration(session.totalDuration))
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                }
                            }
                            .padding(.vertical, 4)
                        }
                    }
                }
            }
        }
        .navigationTitle(title)
        .task {
            await loadSessions()
        }
    }
    
    private func loadSessions() async {
        isLoading = true
        
        do {
            // Load sessions for these IDs
            sessions = try await coordinator.fetchSessions(ids: sessionIds)
            
            // Load word counts in parallel
            guard let dbManager = coordinator.getDatabaseManager() else { return }
            await withTaskGroup(of: (UUID, Int).self) { group in
                for session in sessions {
                    group.addTask {
                        let count = (try? await dbManager.fetchSessionWordCount(sessionId: session.sessionId)) ?? 0
                        return (session.sessionId, count)
                    }
                }
                
                for await (sessionId, wordCount) in group {
                    sessionWordCounts[sessionId] = wordCount
                }
            }
            
            // Sort by start time descending
            sessions.sort { $0.startTime > $1.startTime }
            
        } catch {
            print("‚ùå [FilteredSessionsView] Failed to load sessions: \(error)")
        }
        
        isLoading = false
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let minutes = Int(duration) / 60
        let seconds = Int(duration) % 60
        if minutes > 0 {
            return "\(minutes)m \(seconds)s"
        } else {
            return "\(seconds)s"
        }
    }
}

struct SummaryRow: View {
    let summary: Summary
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(summary.periodType.rawValue.capitalized)
                    .font(.caption)
                    .fontWeight(.semibold)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.blue.opacity(0.2))
                    .clipShape(Capsule())
                
                Spacer()
                
                Text(summary.periodStart, style: .date)
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
            
            Text(summary.text)
                .font(.body)
                .lineLimit(4)
        }
        .padding(.vertical, 8)
    }
}

// MARK: - Settings Tab

struct SettingsTab: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var activeEngineName: String = "Loading..."
    @State private var debugTapCount: Int = 0
    @State private var showDebugSection: Bool = false
    @State private var databasePath: String?
    
    var body: some View {
        NavigationStack {
            List {
                // Recording Section
                Section {
                    NavigationLink(destination: RecordingSettingsView()) {
                        Label {
                            Text("Recording Chunks")
                        } icon: {
                            Image(systemName: "mic.fill")
                                .foregroundStyle(AppTheme.magenta)
                        }
                    }
                }
                
                // AI & Summaries Section
                Section {
                    NavigationLink(destination: AISettingsView()) {
                        Label {
                            VStack(alignment: .leading, spacing: 2) {
                                Text("AI & Summaries")
                                Text(activeEngineName)
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                            }
                        } icon: {
                            Image(systemName: "brain")
                                .foregroundStyle(AppTheme.purple)
                        }
                    }
                } footer: {
                    Text("Configure how your recordings are summarized.")
                }
                
                // Statistics Section
                Section {
                    NavigationLink(destination: StatisticsView()) {
                        Label {
                            Text("Statistics")
                        } icon: {
                            Image(systemName: "chart.xyaxis.line")
                                .foregroundStyle(AppTheme.skyBlue)
                        }
                    }
                } footer: {
                    Text("View word clouds, charts, and statistical analysis.")
                }
                
                // Data Section
                Section {
                    NavigationLink(destination: DataSettingsView()) {
                        Label {
                            Text("Data")
                        } icon: {
                            Image(systemName: "externaldrive.fill")
                                .foregroundStyle(AppTheme.magenta)
                        }
                    }
                }
                
                // Privacy Section
                Section {
                    NavigationLink(destination: PrivacySettingsView()) {
                        Label {
                            Text("Privacy")
                        } icon: {
                            Image(systemName: "lock.shield.fill")
                                .foregroundStyle(AppTheme.darkPurple)
                        }
                    }
                }
                
                // About Section
                Section {
                    HStack {
                        Label {
                            Text("Version")
                        } icon: {
                            Image(systemName: "info.circle")
                                .foregroundStyle(AppTheme.lightPurple)
                        }
                        Spacer()
                        Text("1.0.0")
                            .foregroundStyle(.secondary)
                    }
                    .contentShape(Rectangle())
                    .onTapGesture {
                        debugTapCount += 1
                        if debugTapCount >= 5 {
                            showDebugSection = true
                            coordinator.showSuccess("Debug mode enabled")
                            debugTapCount = 0
                        }
                    }
                    
                    HStack {
                        Label {
                            Text("Transcription: On-Device")
                        } icon: {
                            Image(systemName: "checkmark.shield.fill")
                                .foregroundStyle(AppTheme.emerald)
                        }
                        Spacer()
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundStyle(AppTheme.emerald)
                    }
                } header: {
                    Text("About")
                } footer: {
                    Text("AI summaries use your API keys or on-device fallback.")
                }
                
                // Debug Section (hidden by default)
                if showDebugSection {
                    Section {
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Database Location")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                            if let path = databasePath {
                                Text(path)
                                    .font(.system(.caption2, design: .monospaced))
                                    .foregroundStyle(.primary)
                                    .textSelection(.enabled)
                            } else {
                                Text("Loading...")
                                    .font(.caption2)
                                    .foregroundStyle(.secondary)
                            }
                        }
                        .padding(.vertical, 4)
                        
                        Button {
                            Task {
                                await coordinator.testSessionQueries()
                            }
                        } label: {
                            Label("Test Session Queries", systemImage: "testtube.2")
                        }
                        
                        Button(role: .destructive) {
                            showDebugSection = false
                        } label: {
                            Label("Hide Debug Section", systemImage: "eye.slash")
                        }
                    } header: {
                        Text("Debug")
                    }
                }
            }
            .navigationTitle("Settings")
            .task {
                await loadActiveEngine()
                databasePath = await coordinator.getDatabasePath()
            }
            .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("EngineDidChange"))) { _ in
                Task {
                    await loadActiveEngine()
                }
            }
        }
    }
    
    private func loadActiveEngine() async {
        guard let summCoord = coordinator.summarizationCoordinator else {
            activeEngineName = "Not configured"
            return
        }
        
        let engine = await summCoord.getActiveEngine()
        activeEngineName = engine.displayName
    }
}

// MARK: - Recording Settings View

struct RecordingSettingsView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var chunkDuration: Double = 180
    
    var body: some View {
        List {
            Section {
                VStack(alignment: .leading, spacing: 12) {
                    HStack {
                        Text("Auto-Chunk Duration")
                        Spacer()
                        Text("\(Int(chunkDuration))s")
                            .foregroundStyle(.secondary)
                            .monospacedDigit()
                    }
                    
                    Slider(value: $chunkDuration, in: 30...300, step: 30) {
                        Text("Chunk Duration")
                    }
                    .tint(AppTheme.purple)
                    .onChange(of: chunkDuration) { oldValue, newValue in
                        coordinator.audioCapture.autoChunkDuration = newValue
                        UserDefaults.standard.autoChunkDuration = newValue
                        coordinator.showSuccess("Chunk duration updated to \(Int(newValue))s")
                    }
                }
                .padding(.vertical, 4)
            } header: {
                Text("Chunk Settings")
            } footer: {
                Text("Recordings are automatically split into chunks of this duration for efficient processing and transcription.")
            }
            
            Section {
                HStack {
                    Label("Format", systemImage: "waveform")
                    Spacer()
                    Text("AAC")
                        .foregroundStyle(.secondary)
                }
                
                HStack {
                    Label("Sample Rate", systemImage: "dial.medium")
                    Spacer()
                    Text("44.1 kHz")
                        .foregroundStyle(.secondary)
                }
                
                HStack {
                    Label("Channels", systemImage: "speaker.wave.2")
                    Spacer()
                    Text("Mono")
                        .foregroundStyle(.secondary)
                }
            } header: {
                Text("Audio Quality")
            } footer: {
                Text("Optimized settings for voice recording with smaller file sizes.")
            }
            
            Section {
                NavigationLink(destination: LanguageSettingsView()) {
                    Label {
                        VStack(alignment: .leading, spacing: 2) {
                            Text("Languages")
                            Text("Manage which languages can be detected")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    } icon: {
                        Image(systemName: "globe")
                            .foregroundStyle(AppTheme.emerald)
                    }
                }
            } header: {
                Text("Detection")
            }
        }
        .navigationTitle("Recording Chunks")
        .navigationBarTitleDisplayMode(.inline)
        .task {
            // Load saved setting or use current value
            let savedDuration = UserDefaults.standard.autoChunkDuration
            chunkDuration = savedDuration
            coordinator.audioCapture.autoChunkDuration = savedDuration
        }
    }
}

// MARK: - AI Settings View

struct AISettingsView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var activeEngine: EngineTier?
    @State private var availableEngines: [EngineTier] = []
    @State private var isLoading = true
    @State private var showingSmartestConfig = false
    @State private var wiggleAPIKeyField = false
    
    // Local AI model state
    @State private var localModelStatus: String = "Checking..."
    @State private var isLocalModelDownloaded: Bool = false
    @State private var showDeleteConfirmation: Bool = false
    @State private var wiggleLocalAIButton = false
    
    // Scroll proxy for programmatic scrolling
    @State private var scrollProxy: ScrollViewProxy?
    
    // External API state
    @State private var selectedProvider: String = UserDefaults.standard.string(forKey: "externalAPIProvider") ?? "OpenAI"
    @State private var selectedModel: String = UserDefaults.standard.string(forKey: "externalAPIModel") ?? "gpt-4.1"
    @State private var apiKey: String = ""
    @State private var showAPIKeyField = false
    
    // API Key testing state
    @State private var isTesting = false
    @State private var testResult: String?
    @State private var testSuccess = false
    
    // Available models per provider
    private let openaiModels = [
        ("gpt-4.1", "GPT-4.1 (Recommended)"),
        ("gpt-4.1-mini", "GPT-4.1 Mini (Faster)"),
        ("gpt-4o", "GPT-4o"),
        ("gpt-4o-mini", "GPT-4o Mini"),
        ("gpt-3.5-turbo", "GPT-3.5 Turbo (Cheapest)")
    ]
    
    private let anthropicModels = [
        ("claude-sonnet-4-5", "Claude Sonnet 4.5 (Recommended)"),
        ("claude-haiku-4-5", "Claude Haiku 4.5 (Fastest)"),
        ("claude-opus-4-5", "Claude Opus 4.5 (Most Capable)"),
        ("claude-sonnet-4-20250514", "Claude Sonnet 4 (Legacy)"),
        ("claude-3-5-sonnet-20241022", "Claude 3.5 Sonnet (Legacy)")
    ]
    
    private var currentModels: [(String, String)] {
        selectedProvider == "OpenAI" ? openaiModels : anthropicModels
    }
    
    var body: some View {
        ScrollViewReader { proxy in
            List {
                // MARK: - Summary Quality Picker
                Section {
                // Smart (Basic)
                SummaryQualityCard(
                    emoji: "‚ö°Ô∏è",
                    title: "Smart",
                    subtitle: "Quick word-based summaries",
                    detail: "Always available, works offline",
                    tier: .basic,
                    isSelected: activeEngine == .basic,
                    isAvailable: true,
                    onSelect: { selectEngine(.basic) }
                )
                
                // Local AI (Phi-3.5)
                SummaryQualityCard(
                    emoji: "ü§ñ",
                    title: "Local AI",
                    subtitle: coordinator.localModelDisplayName,
                    detail: localModelStatus,
                    tier: .local,
                    isSelected: activeEngine == .local,
                    isAvailable: isLocalModelDownloaded,
                    onSelect: { selectEngine(.local) }
                )
                
                // Smarter (Apple Intelligence)
                SummaryQualityCard(
                    emoji: "üß†",
                    title: "Smarter",
                    subtitle: "Apple Intelligence",
                    detail: availableEngines.contains(.apple) ? "On-device AI, works offline" : "Requires iOS 18.1+ and compatible device",
                    tier: .apple,
                    isSelected: activeEngine == .apple,
                    isAvailable: availableEngines.contains(.apple),
                    onSelect: { selectEngine(.apple) }
                )
                
                // Smartest (External API)
                SummaryQualityCard(
                    emoji: "‚ú®",
                    title: "Smartest",
                    subtitle: hasValidAPIKey() ? "\(selectedProvider) ‚Ä¢ \(selectedModel)" : "OpenAI or Anthropic",
                    detail: hasValidAPIKey() ? "Best quality, requires internet" : "Tap to configure your API key",
                    tier: .external,
                    isSelected: activeEngine == .external,
                    isAvailable: true,
                    onSelect: { selectEngine(.external) }
                )
            } header: {
                Text("Summary Quality")
            } footer: {
                Text("Choose how you want your audio summaries generated. Smartest requires your own API key.")
            }
            
            // MARK: - Smartest Configuration
            if activeEngine == .external {
                Section {
                    // Provider Selection
                    Picker("Provider", selection: $selectedProvider) {
                        Text("OpenAI").tag("OpenAI")
                        Text("Anthropic").tag("Anthropic")
                    }
                    .pickerStyle(.segmented)
                    .onChange(of: selectedProvider) { _, newValue in
                        UserDefaults.standard.set(newValue, forKey: "externalAPIProvider")
                        let defaultModel = newValue == "OpenAI" ? "gpt-4.1" : "claude-sonnet-4-5"
                        selectedModel = defaultModel
                        UserDefaults.standard.set(defaultModel, forKey: "externalAPIModel")
                        loadAPIKey()
                    }
                    
                    // Model Selection
                    Picker("Model", selection: $selectedModel) {
                        ForEach(currentModels, id: \.0) { model in
                            Text(model.1).tag(model.0)
                        }
                    }
                    .onChange(of: selectedModel) { _, newValue in
                        UserDefaults.standard.set(newValue, forKey: "externalAPIModel")
                    }
                    
                    // API Key Input
                    if showAPIKeyField {
                        VStack(spacing: 8) {
                            HStack {
                                SecureField("API Key", text: $apiKey)
                                    .textContentType(.password)
                                    .autocapitalization(.none)
                                    .autocorrectionDisabled()
                                    .onChange(of: apiKey) { _, newValue in
                                        let normalized = newValue.trimmingCharacters(in: .whitespacesAndNewlines)
                                        if normalized != newValue {
                                            apiKey = normalized
                                        }
                                        testResult = nil
                                    }
                                
                                Button("Test") {
                                    testAPIKey()
                                }
                                .buttonStyle(.bordered)
                                .disabled(apiKey.isEmpty || isTesting)
                                
                                Button("Save") {
                                    saveAPIKey()
                                }
                                .buttonStyle(.borderedProminent)
                                .disabled(apiKey.isEmpty)
                            }
                            .modifier(WiggleModifier(wiggle: $wiggleAPIKeyField))
                            
                            // Instructional text
                            if !hasValidAPIKey() {
                                HStack(spacing: 8) {
                                    Image(systemName: "exclamationmark.circle.fill")
                                        .foregroundStyle(.orange)
                                    Text("Save your API key to activate Smartest summaries")
                                        .font(.caption)
                                        .foregroundStyle(.orange)
                                }
                            }
                            
                            if let result = testResult {
                                Label(result, systemImage: testSuccess ? "checkmark.circle.fill" : "xmark.circle.fill")
                                    .font(.caption)
                                    .foregroundStyle(testSuccess ? .green : .red)
                            }
                        }
                    } else {
                        Button {
                            showAPIKeyField = true
                        } label: {
                            Label(hasValidAPIKey() ? "Change API Key" : "Add API Key", 
                                  systemImage: hasValidAPIKey() ? "pencil" : "key.fill")
                        }
                    }
                    
                    // Help link
                    Link(destination: URL(string: selectedProvider == "OpenAI" 
                        ? "https://platform.openai.com/api-keys" 
                        : "https://console.anthropic.com/settings/keys")!) {
                        Label("Get \(selectedProvider) API Key", systemImage: "arrow.up.right.square")
                            .font(.footnote)
                    }
                    
                    // Remove key
                    if hasValidAPIKey() {
                        Button(role: .destructive) {
                            clearAPIKey()
                        } label: {
                            Label("Remove API Key", systemImage: "trash")
                        }
                    }
                } header: {
                    Text("Smartest Configuration")
                } footer: {
                    if hasValidAPIKey() {
                        Text("Your API key connects to \(selectedProvider == "OpenAI" ? "api.openai.com" : "api.anthropic.com"). Keys are stored securely and never shared.")
                    } else {
                        Text("Add your own OpenAI or Anthropic API key to unlock the Smartest summaries. Keys are stored securely in your device's Keychain.")
                    }
                }
                .id("smartestConfig")
            }
            
            // MARK: - Local AI Model Management
            if activeEngine == .local {
                Section {
                    if coordinator.isDownloadingLocalModel {
                        VStack(spacing: 12) {
                            ProgressView()
                                .scaleEffect(1.2)
                            
                            Text("Downloading \(coordinator.localModelDisplayName)...")
                                .font(.subheadline)
                                .foregroundStyle(.secondary)
                            
                            Text("You can leave this screen. We'll notify you when the download is complete.")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                                .multilineTextAlignment(.center)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                    } else if isLocalModelDownloaded {
                    HStack {
                        VStack(alignment: .leading, spacing: 4) {
                            Text(coordinator.localModelDisplayName)
                                .font(.subheadline)
                            Text(localModelStatus)
                                .font(.caption)
                                .foregroundStyle(.green)
                        }
                        Spacer()
                        Button(role: .destructive) {
                            showDeleteConfirmation = true
                        } label: {
                            Label("Delete", systemImage: "trash")
                                .font(.caption)
                        }
                        .buttonStyle(.bordered)
                        .modifier(WiggleModifier(wiggle: $wiggleLocalAIButton))
                    }
                } else {
                    HStack {
                        VStack(alignment: .leading, spacing: 4) {
                            Text(coordinator.localModelDisplayName)
                                .font(.subheadline)
                            Text("Not Downloaded ‚Ä¢ \(coordinator.expectedLocalModelSizeMB)")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                        Spacer()
                        Button {
                            downloadLocalModel()
                        } label: {
                            Label("Download", systemImage: "arrow.down.circle")
                                .font(.caption)
                        }
                        .buttonStyle(.borderedProminent)
                        .tint(.purple)
                        .modifier(WiggleModifier(wiggle: $wiggleLocalAIButton))
                    }
                }
            } header: {
                Text("Local AI Model")
            } footer: {
                if coordinator.isDownloadingLocalModel {
                    Text("Download continues in the background. You'll receive a notification when complete.")
                } else if !isLocalModelDownloaded {
                    Text("Download the local AI model to enable on-device summarization. It runs entirely on your device for maximum privacy.")
                } else {
                    Text("The local AI model enables on-device summarization. It runs entirely on your device for maximum privacy.")
                }
            }
            .alert("Delete Local AI Model?", isPresented: $showDeleteConfirmation) {
                Button("Cancel", role: .cancel) { }
                Button("Delete", role: .destructive) {
                    deleteLocalModel()
                }
            } message: {
                Text("This will remove the \\(coordinator.expectedLocalModelSizeMB) model from your device. You can re-download it anytime.")
            }
            .id("localAIConfig")
            } // End of if activeEngine == .local
        }
        .navigationTitle("AI & Summaries")
        .task {
            await loadEngineStatus()
            loadAPIKey()
        }
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("EngineDidChange"))) { _ in
            Task {
                await loadEngineStatus()
            }
        }
        .onChange(of: coordinator.isDownloadingLocalModel) { wasDownloading, isDownloading in
            // Refresh model status when download completes
            if wasDownloading && !isDownloading {
                Task {
                    isLocalModelDownloaded = await coordinator.isLocalModelDownloaded()
                    localModelStatus = await coordinator.localModelSizeFormatted()
                }
            }
        }
        .onAppear {
            // Store proxy for scrolling
            scrollProxy = proxy
        }
        }
    }
    
    // MARK: - Helper Methods
    
    private func loadEngineStatus() async {
        isLoading = true
        defer { isLoading = false }
        
        guard let summCoord = coordinator.summarizationCoordinator else { return }
        activeEngine = await summCoord.getActiveEngine()
        availableEngines = await summCoord.getAvailableEngines()
        
        // Load local model status
        isLocalModelDownloaded = await coordinator.isLocalModelDownloaded()
        localModelStatus = await coordinator.localModelSizeFormatted()
    }
    
    private func downloadLocalModel() {
        // Use coordinator's background download method
        // Download state persists in coordinator even if view navigates away
        coordinator.startLocalModelDownload()
    }
    
    private func deleteLocalModel() {
        Task {
            do {
                try await coordinator.deleteLocalModel()
                await MainActor.run {
                    isLocalModelDownloaded = false
                    localModelStatus = "Not Downloaded"
                }
                // Refresh status
                await loadEngineStatus()
            } catch {
                coordinator.showError("Delete failed: \(error.localizedDescription)")
            }
        }
    }
    
    private func selectEngine(_ tier: EngineTier) {
        // For Local AI without model, show download section with wiggle animation
        if tier == .local {
            // Haptic feedback
            let generator = UINotificationFeedbackGenerator()
            generator.notificationOccurred(.warning)
            
            // Update activeEngine immediately so section appears right away
            activeEngine = .local
            
            // Persist engine preference in background (without triggering refresh)
            Task {
                guard let summCoord = coordinator.summarizationCoordinator else { return }
                await summCoord.setPreferredEngine(tier)
            }
            
            // Scroll to the section after a brief delay to ensure it's rendered
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                withAnimation {
                    scrollProxy?.scrollTo("localAIConfig", anchor: .top)
                }
            }
            
            // If model not downloaded, trigger wiggle animation on button
            if !isLocalModelDownloaded {
                withAnimation(.default) {
                    wiggleLocalAIButton = true
                }
                
                // Reset wiggle after animation
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    wiggleLocalAIButton = false
                }
            }
            
            return
        }
        
        if tier == .apple && !availableEngines.contains(.apple) {
            coordinator.showError("Apple Intelligence requires iOS 18.1+ and compatible hardware")
            return
        }
        
        // If selecting Smartest without API key, show config section with feedback
        if tier == .external && !hasValidAPIKey() {
            // Haptic feedback
            let generator = UINotificationFeedbackGenerator()
            generator.notificationOccurred(.warning)
            
            // Update activeEngine immediately so section appears right away
            activeEngine = .external
            
            // Persist engine preference in background (without triggering refresh)
            Task {
                guard let summCoord = coordinator.summarizationCoordinator else { return }
                await summCoord.setPreferredEngine(tier)
            }
            
            // Show config and trigger wiggle animation
            showingSmartestConfig = true
            showAPIKeyField = true
            
            // Scroll to the section after a brief delay to ensure it's rendered
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                withAnimation {
                    scrollProxy?.scrollTo("smartestConfig", anchor: .top)
                }
            }
            
            // Trigger wiggle animation
            withAnimation(.default) {
                wiggleAPIKeyField = true
            }
            
            // Reset wiggle after animation
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                wiggleAPIKeyField = false
            }
            
            return
        }
        
        Task {
            guard let summCoord = coordinator.summarizationCoordinator else { return }
            await summCoord.setPreferredEngine(tier)
            await loadEngineStatus()
            NotificationCenter.default.post(name: NSNotification.Name("EngineDidChange"), object: nil)
            coordinator.showSuccess("Switched to \(tierDisplayName(tier))")
        }
    }
    
    private func tierDisplayName(_ tier: EngineTier) -> String {
        switch tier {
        case .basic: return "Smart"
        case .apple: return "Smarter"
        case .external: return "Smartest"
        default: return tier.displayName
        }
    }
    
    private func hasValidAPIKey() -> Bool {
        let key = selectedProvider == "OpenAI" 
            ? KeychainHelper.load(key: "openai_api_key")
            : KeychainHelper.load(key: "anthropic_api_key")
        return key != nil && !key!.isEmpty
    }
    
    private func loadAPIKey() {
        let keychainKey = selectedProvider == "OpenAI" ? "openai_api_key" : "anthropic_api_key"
        apiKey = KeychainHelper.load(key: keychainKey) ?? ""
        showAPIKeyField = false
    }
    
    private func saveAPIKey() {
        let keychainKey = selectedProvider == "OpenAI" ? "openai_api_key" : "anthropic_api_key"
        
        if KeychainHelper.save(key: keychainKey, value: apiKey) {
            UserDefaults.standard.set(selectedProvider, forKey: "externalAPIProvider")
            UserDefaults.standard.set(selectedModel, forKey: "externalAPIModel")
            showAPIKeyField = false
            showingSmartestConfig = false
            
            // Now that we have a valid key, switch to Smartest engine
            Task {
                guard let summCoord = coordinator.summarizationCoordinator else { return }
                await summCoord.setPreferredEngine(.external)
                await loadEngineStatus()
                NotificationCenter.default.post(name: NSNotification.Name("EngineDidChange"), object: nil)
                coordinator.showSuccess("API key saved - Switched to Smartest")
            }
        } else {
            coordinator.showError("Failed to save API key")
        }
    }
    
    private func testAPIKey() {
        isTesting = true
        testResult = nil
        
        Task {
            guard !apiKey.isEmpty else {
                await MainActor.run {
                    testSuccess = false
                    testResult = "Please enter an API key"
                    isTesting = false
                }
                return
            }
            
            guard let summCoord = coordinator.summarizationCoordinator else {
                await MainActor.run {
                    testSuccess = false
                    testResult = "Summarization not initialized"
                    isTesting = false
                }
                return
            }
            
            let provider: ExternalAPIEngine.Provider = selectedProvider == "OpenAI" ? .openai : .anthropic
            let result = await summCoord.validateExternalAPIKey(apiKey, for: provider)
            
            await MainActor.run {
                testSuccess = result.isValid
                testResult = result.message
                isTesting = false
            }
        }
    }
    
    private func clearAPIKey() {
        let keychainKey = selectedProvider == "OpenAI" ? "openai_api_key" : "anthropic_api_key"
        KeychainHelper.delete(key: keychainKey)
        apiKey = ""
        showAPIKeyField = false
        showingSmartestConfig = false
        
        if activeEngine == .external {
            selectEngine(.basic)
        }
        
        coordinator.showSuccess("API key removed")
        
        Task {
            await loadEngineStatus()
            NotificationCenter.default.post(name: NSNotification.Name("EngineDidChange"), object: nil)
        }
    }
}

// MARK: - Summary Quality Card

struct SummaryQualityCard: View {
    let emoji: String
    let title: String
    let subtitle: String
    let detail: String
    let tier: EngineTier
    let isSelected: Bool
    let isAvailable: Bool
    let onSelect: () -> Void
    
    var body: some View {
        Button(action: onSelect) {
            HStack(spacing: 12) {
                // Selection indicator
                ZStack {
                    Circle()
                        .strokeBorder(isSelected ? AppTheme.purple : Color.gray.opacity(0.5), lineWidth: 2)
                        .frame(width: 24, height: 24)
                    
                    if isSelected {
                        Circle()
                            .fill(AppTheme.purple)
                            .frame(width: 12, height: 12)
                    }
                }
                
                // Emoji
                Text(emoji)
                    .font(.title2)
                
                // Content
                VStack(alignment: .leading, spacing: 4) {
                    Text(title)
                        .font(.headline)
                        .foregroundStyle(.primary)
                    
                    Text(subtitle)
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                    
                    Text(detail)
                        .font(.caption)
                        .foregroundStyle(isAvailable ? .secondary : Color.orange)
                }
                
                Spacer()
                
                // Lock icon if unavailable
                if !isAvailable {
                    Image(systemName: "lock.fill")
                        .foregroundStyle(.secondary)
                        .font(.caption)
                }
            }
            .padding()
            .background(Color(.secondarySystemBackground))
            .cornerRadius(12)
            .opacity(isAvailable ? 1.0 : 0.6)
        }
        .buttonStyle(.plain)
    }
}

// MARK: - On-Device Engines View (Keep for backward compatibility)

struct OnDeviceEnginesView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var activeEngine: EngineTier?
    @State private var availableEngines: [EngineTier] = []
    @State private var isLoading = true
    @State private var showUnavailableAlert = false
    @State private var selectedUnavailableTier: EngineTier?
    
    var body: some View {
        List {
            Section {
                ForEach(EngineTier.privateTiers, id: \.self) { tier in
                    EngineSelectionRow(
                        tier: tier,
                        isActive: tier == activeEngine,
                        isAvailable: availableEngines.contains(tier)
                    ) {
                        selectEngine(tier)
                    }
                }
            } header: {
                Text("Select Engine")
            } footer: {
                Text("Tap an engine to activate it. All on-device engines process data locally for privacy.")
            }
        }
        .navigationTitle("On-Device Engines")
        .navigationBarTitleDisplayMode(.inline)
        .task {
            await loadEngineStatus()
        }
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("EngineDidChange"))) { _ in
            Task {
                await loadEngineStatus()
            }
        }
        .alert("Engine Unavailable", isPresented: $showUnavailableAlert) {
            Button("OK", role: .cancel) { }
        } message: {
            if let tier = selectedUnavailableTier {
                Text(unavailableMessage(for: tier))
            }
        }
    }
    
    private func loadEngineStatus() async {
        isLoading = true
        defer { isLoading = false }
        
        guard let summCoord = coordinator.summarizationCoordinator else { return }
        activeEngine = await summCoord.getActiveEngine()
        availableEngines = await summCoord.getAvailableEngines()
    }
    
    private func selectEngine(_ tier: EngineTier) {
        if tier == activeEngine { return }
        
        guard availableEngines.contains(tier) else {
            selectedUnavailableTier = tier
            showUnavailableAlert = true
            return
        }
        
        Task {
            guard let summCoord = coordinator.summarizationCoordinator else { return }
            await summCoord.setPreferredEngine(tier)
            await loadEngineStatus()
            NotificationCenter.default.post(name: NSNotification.Name("EngineDidChange"), object: nil)
            coordinator.showSuccess("Switched to \(tier.displayName)")
        }
    }
    
    private func unavailableMessage(for tier: EngineTier) -> String {
        switch tier {
        case .basic:
            return "Basic engine should always be available. Please restart the app."
        case .local:
            return "Download the local AI model to use on-device intelligence."
        case .apple:
            return "Apple Intelligence requires iOS 18.1+ and compatible hardware."
        case .external:
            return "Configure your API key to use external AI services."
        }
    }
}

// MARK: - Engine Selection Row

struct EngineSelectionRow: View {
    let tier: EngineTier
    let isActive: Bool
    let isAvailable: Bool
    let onTap: () -> Void
    
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 12) {
                Image(systemName: tier.icon)
                    .font(.title3)
                    .foregroundStyle(isAvailable ? .blue : .secondary)
                    .frame(width: 32)
                
                VStack(alignment: .leading, spacing: 2) {
                    Text(tier.displayName)
                        .font(.body)
                        .foregroundStyle(isAvailable ? .primary : .secondary)
                    
                    Text(tier.subtitle)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                
                Spacer()
                
                if isActive {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundStyle(.green)
                } else if !isAvailable {
                    Text("Unavailable")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
            }
        }
        .buttonStyle(.plain)
    }
}

// MARK: - External API Settings View

struct ExternalAPISettingsView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var activeEngine: EngineTier?
    @State private var availableEngines: [EngineTier] = []
    @State private var isLoading = true
    @State private var selectedProvider: String = UserDefaults.standard.string(forKey: "externalAPIProvider") ?? "OpenAI"
    @State private var selectedModel: String = UserDefaults.standard.string(forKey: "externalAPIModel") ?? "gpt-4.1"
    @State private var openaiKey: String = ""
    @State private var anthropicKey: String = ""
    @State private var isTesting = false
    @State private var testResult: String?
    @State private var testSuccess: Bool = false
    
    // Available models per provider
    private let openaiModels = [
        ("gpt-4.1", "GPT-4.1 (Recommended)"),
        ("gpt-4.1-mini", "GPT-4.1 Mini (Faster)"),
        ("gpt-4o", "GPT-4o"),
        ("gpt-4o-mini", "GPT-4o Mini"),
        ("gpt-3.5-turbo", "GPT-3.5 Turbo (Cheapest)")
    ]
    
    private let anthropicModels = [
        ("claude-sonnet-4-5", "Claude Sonnet 4.5 (Recommended)"),
        ("claude-haiku-4-5", "Claude Haiku 4.5 (Fastest)"),
        ("claude-opus-4-5", "Claude Opus 4.5 (Most Capable)"),
        ("claude-sonnet-4-20250514", "Claude Sonnet 4 (Legacy)"),
        ("claude-3-5-sonnet-20241022", "Claude 3.5 Sonnet (Legacy)")
    ]
    
    private var currentModels: [(String, String)] {
        selectedProvider == "OpenAI" ? openaiModels : anthropicModels
    }
    
    private var currentKey: String {
        selectedProvider == "OpenAI" ? openaiKey : anthropicKey
    }
    
    var body: some View {
        List {
            // Status
            Section {
                EngineSelectionRow(
                    tier: .external,
                    isActive: activeEngine == .external,
                    isAvailable: availableEngines.contains(.external)
                ) {
                    activateExternalEngine()
                }
            } header: {
                Text("Status")
            } footer: {
                if availableEngines.contains(.external) {
                    Text("External API is configured and ready to use.")
                } else {
                    Text("Configure an API key below to enable external AI.")
                }
            }
            
            // Provider Selection
            Section {
                Picker("Provider", selection: $selectedProvider) {
                    Text("OpenAI").tag("OpenAI")
                    Text("Anthropic").tag("Anthropic")
                }
                .pickerStyle(.segmented)
                .onChange(of: selectedProvider) { _, newValue in
                    UserDefaults.standard.set(newValue, forKey: "externalAPIProvider")
                    // Reset to default model for new provider
                    let defaultModel = newValue == "OpenAI" ? "gpt-4.1" : "claude-sonnet-4-5"
                    selectedModel = defaultModel
                    UserDefaults.standard.set(defaultModel, forKey: "externalAPIModel")
                }
            } header: {
                Text("AI Provider")
            }
            
            // Model Selection
            Section {
                Picker("Model", selection: $selectedModel) {
                    ForEach(currentModels, id: \.0) { model in
                        Text(model.1).tag(model.0)
                    }
                }
                .onChange(of: selectedModel) { _, newValue in
                    UserDefaults.standard.set(newValue, forKey: "externalAPIModel")
                    coordinator.showSuccess("Model updated to \(newValue)")
                }
            } header: {
                Text("Model")
            } footer: {
                Text("Different models have varying capabilities, speed, and cost.")
            }
            
            // API Key Input
            Section {
                if selectedProvider == "OpenAI" {
                    SecureField("OpenAI API Key", text: $openaiKey)
                        .textContentType(.password)
                        .autocapitalization(.none)
                        .autocorrectionDisabled()
                        .onChange(of: openaiKey) { _, newValue in
                            // Normalize: trim whitespace and newlines
                            let normalized = newValue.trimmingCharacters(in: .whitespacesAndNewlines)
                            if normalized != newValue {
                                openaiKey = normalized
                            }
                        }
                    
                    if !openaiKey.isEmpty {
                        HStack {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundStyle(.green)
                            Text("API key configured")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    }
                    
                    Link(destination: URL(string: "https://platform.openai.com/api-keys")!) {
                        Label("Get OpenAI API Key", systemImage: "arrow.up.right.square")
                    }
                } else {
                    SecureField("Anthropic API Key", text: $anthropicKey)
                        .textContentType(.password)
                        .autocapitalization(.none)
                        .autocorrectionDisabled()
                        .onChange(of: anthropicKey) { _, newValue in
                            // Normalize: trim whitespace and newlines
                            let normalized = newValue.trimmingCharacters(in: .whitespacesAndNewlines)
                            if normalized != newValue {
                                anthropicKey = normalized
                            }
                        }
                    
                    if !anthropicKey.isEmpty {
                        HStack {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundStyle(.green)
                            Text("API key configured")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    }
                    
                    Link(destination: URL(string: "https://console.anthropic.com/settings/keys")!) {
                        Label("Get Anthropic API Key", systemImage: "arrow.up.right.square")
                    }
                }
            } header: {
                Text("API Key")
            } footer: {
                Text("Your API key is stored securely in the device keychain.")
            }
            
            // Test & Save
            Section {
                Button {
                    testAPIKey()
                } label: {
                    HStack {
                        if isTesting {
                            ProgressView()
                                .scaleEffect(0.8)
                            Text("Testing...")
                        } else {
                            Label("Test API Key", systemImage: "checkmark.shield")
                        }
                    }
                }
                .disabled(currentKey.isEmpty || isTesting)
                
                if let result = testResult {
                    Label(result, systemImage: testSuccess ? "checkmark.circle.fill" : "xmark.circle.fill")
                        .foregroundStyle(testSuccess ? .green : .red)
                }
                
                Button {
                    saveAPIKey()
                } label: {
                    Label("Save API Key", systemImage: "square.and.arrow.down")
                }
                .disabled(currentKey.isEmpty)
            }
            
            // Clear Keys
            if !openaiKey.isEmpty || !anthropicKey.isEmpty {
                Section {
                    Button(role: .destructive) {
                        clearAPIKeys()
                    } label: {
                        Label("Clear All API Keys", systemImage: "trash")
                    }
                }
            }
            
            // Warning
            Section {
                Label {
                    Text("Data will be sent to \(selectedProvider) servers for processing.")
                } icon: {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .foregroundStyle(.orange)
                }
            } header: {
                Text("Privacy Notice")
            }
        }
        .navigationTitle("External API")
        .navigationBarTitleDisplayMode(.inline)
        .task {
            await loadEngineStatus()
            loadSavedKeys()
        }
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("EngineDidChange"))) { _ in
            Task {
                await loadEngineStatus()
            }
        }
    }
    
    private func loadEngineStatus() async {
        isLoading = true
        defer { isLoading = false }
        
        guard let summCoord = coordinator.summarizationCoordinator else { return }
        activeEngine = await summCoord.getActiveEngine()
        availableEngines = await summCoord.getAvailableEngines()
    }
    
    private func loadSavedKeys() {
        // Load from keychain
        openaiKey = KeychainHelper.load(key: "openai_api_key") ?? ""
        anthropicKey = KeychainHelper.load(key: "anthropic_api_key") ?? ""
        
        // Load saved model selection
        if let savedModel = UserDefaults.standard.string(forKey: "externalAPIModel") {
            selectedModel = savedModel
        }
    }
    
    private func activateExternalEngine() {
        guard availableEngines.contains(.external) else {
            coordinator.showError("Configure an API key first")
            return
        }
        
        Task {
            guard let summCoord = coordinator.summarizationCoordinator else { return }
            await summCoord.setPreferredEngine(.external)
            await loadEngineStatus()
            NotificationCenter.default.post(name: NSNotification.Name("EngineDidChange"), object: nil)
            coordinator.showSuccess("Switched to External API")
        }
    }
    
    private func testAPIKey() {
        isTesting = true
        testResult = nil
        
        Task {
            let key = currentKey
            guard !key.isEmpty else {
                await MainActor.run {
                    testSuccess = false
                    testResult = "Please enter an API key"
                    isTesting = false
                }
                return
            }
            
            // Use the ExternalAPIEngine to validate the key with a real API request
            guard let summCoord = coordinator.summarizationCoordinator else {
                await MainActor.run {
                    testSuccess = false
                    testResult = "Summarization not initialized"
                    isTesting = false
                }
                return
            }
            
            let provider: ExternalAPIEngine.Provider = selectedProvider == "OpenAI" ? .openai : .anthropic
            let result = await summCoord.validateExternalAPIKey(key, for: provider)
            
            await MainActor.run {
                testSuccess = result.isValid
                testResult = result.message
                isTesting = false
            }
        }
    }
    
    private func saveAPIKey() {
        // Save to keychain
        let key = currentKey
        let keychainKey = selectedProvider == "OpenAI" ? "openai_api_key" : "anthropic_api_key"
        
        if KeychainHelper.save(key: keychainKey, value: key) {
            UserDefaults.standard.set(selectedProvider, forKey: "externalAPIProvider")
            UserDefaults.standard.set(selectedModel, forKey: "externalAPIModel")
            coordinator.showSuccess("API key saved securely")
            
            Task {
                await loadEngineStatus()
                NotificationCenter.default.post(name: NSNotification.Name("EngineDidChange"), object: nil)
            }
        } else {
            coordinator.showError("Failed to save API key")
        }
    }
    
    private func clearAPIKeys() {
        KeychainHelper.delete(key: "openai_api_key")
        KeychainHelper.delete(key: "anthropic_api_key")
        openaiKey = ""
        anthropicKey = ""
        coordinator.showSuccess("API keys cleared")
        
        Task {
            await loadEngineStatus()
            NotificationCenter.default.post(name: NSNotification.Name("EngineDidChange"), object: nil)
        }
    }
}

// MARK: - Statistics Settings View

struct StatisticsView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var wordLimit: Double = 20
    @State private var dateFormat: String = UserDefaults.standard.rollupDateFormat
    @State private var timeFormat: String = UserDefaults.standard.rollupTimeFormat
    
    // Statistics data
    @State private var sessionsByHour: [(hour: Int, count: Int, sessionIds: [UUID])] = []
    @State private var sessionsByDayOfWeek: [(dayOfWeek: Int, count: Int, sessionIds: [UUID])] = []
    @State private var longestSession: (sessionId: UUID, duration: TimeInterval, date: Date)?
    @State private var mostActiveMonth: (year: Int, month: Int, count: Int, sessionIds: [UUID])?
    @State private var topWords: [WordFrequency] = []
    @State private var dailySentiment: [(date: Date, sentiment: Double)] = []
    @State private var languageDistribution: [(language: String, wordCount: Int)] = []
    @State private var isLoadingStats = false
    
    private let wordLimitKey = "insightsWordLimit"
    
    private let dateFormatOptions = [
        ("MM/dd/yyyy", "12/22/2025"),
        ("dd/MM/yyyy", "22/12/2025"),
        ("yyyy-MM-dd", "2025-12-22"),
        ("MMM d, yyyy", "Dec 22, 2025"),
        ("MMMM d, yyyy", "December 22, 2025")
    ]
    
    private let timeFormatOptions = [
        ("HH:mm", "14:30 (24-hour)"),
        ("hh:mm a", "02:30 PM (12-hour)"),
        ("h:mm a", "2:30 PM (12-hour)")
    ]
    
    var body: some View {
        List {
            // Key Statistics Section
            if longestSession != nil || mostActiveMonth != nil {
                Section {
                    if let longest = longestSession {
                        NavigationLink {
                            FilteredSessionsView(
                                title: "Longest Session",
                                sessionIds: [longest.sessionId]
                            )
                        } label: {
                            HStack(spacing: 12) {
                                Image(systemName: "timer")
                                    .font(.title2)
                                    .foregroundStyle(AppTheme.purple)
                                    .frame(width: 40, height: 40)
                                    .background(
                                        RadialGradient(
                                            colors: [AppTheme.purple.opacity(0.15), AppTheme.purple.opacity(0.05)],
                                            center: .center,
                                            startRadius: 0,
                                            endRadius: 20
                                        )
                                    )
                                    .clipShape(RoundedRectangle(cornerRadius: 8))
                                
                                VStack(alignment: .leading, spacing: 4) {
                                    Text("Longest Session")
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                    HStack {
                                        Text(formatDuration(longest.duration))
                                            .font(.title3)
                                            .fontWeight(.semibold)
                                        Spacer()
                                        Text(longest.date.formatted(date: .abbreviated, time: .omitted))
                                            .font(.caption)
                                            .foregroundStyle(.secondary)
                                    }
                                }
                            }
                            .padding(.vertical, 4)
                        }
                    }
                    
                    if let mostActive = mostActiveMonth {
                        NavigationLink {
                            FilteredSessionsView(
                                title: formatMonth(year: mostActive.year, month: mostActive.month),
                                sessionIds: mostActive.sessionIds
                            )
                        } label: {
                            HStack(spacing: 12) {
                                Image(systemName: "calendar.badge.plus")
                                    .font(.title2)
                                    .foregroundStyle(AppTheme.magenta)
                                    .frame(width: 40, height: 40)
                                    .background(
                                        RadialGradient(
                                            colors: [AppTheme.magenta.opacity(0.15), AppTheme.magenta.opacity(0.05)],
                                            center: .center,
                                            startRadius: 0,
                                            endRadius: 20
                                        )
                                    )
                                    .clipShape(RoundedRectangle(cornerRadius: 8))
                                
                                VStack(alignment: .leading, spacing: 4) {
                                    Text("Most Active Month")
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                    HStack {
                                        Text(formatMonth(year: mostActive.year, month: mostActive.month))
                                            .font(.title3)
                                            .fontWeight(.semibold)
                                        Spacer()
                                        Text("\(mostActive.count) session\(mostActive.count == 1 ? "" : "s")")
                                            .font(.caption)
                                            .foregroundStyle(.secondary)
                                    }
                                }
                            }
                            .padding(.vertical, 4)
                        }
                    }
                } header: {
                    Text("Key Statistics")
                }
            }
            
            // Sessions by Hour Section
            if !sessionsByHour.isEmpty {
                Section {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 12) {
                            ForEach(sessionsByHour.sorted(by: { $0.hour < $1.hour }), id: \.hour) { data in
                                NavigationLink {
                                    FilteredSessionsView(
                                        title: formatHour(data.hour),
                                        sessionIds: data.sessionIds
                                    )
                                } label: {
                                    VStack(spacing: 4) {
                                        Text(formatHourShort(data.hour))
                                            .font(.caption)
                                            .fontWeight(.semibold)
                                            .foregroundStyle(AppTheme.skyBlue)
                                        Text("\(data.count)")
                                            .font(.title3)
                                            .fontWeight(.bold)
                                        Text(data.count == 1 ? "session" : "sessions")
                                            .font(.caption2)
                                            .foregroundStyle(.secondary)
                                    }
                                    .frame(width: 70)
                                    .padding(.vertical, 8)
                                    .background(
                                        RadialGradient(
                                            colors: [AppTheme.skyBlue.opacity(0.15), AppTheme.skyBlue.opacity(0.05)],
                                            center: .center,
                                            startRadius: 0,
                                            endRadius: 35
                                        )
                                    )
                                    .clipShape(RoundedRectangle(cornerRadius: 8))
                                }
                                .buttonStyle(.plain)
                            }
                        }
                        .padding(.horizontal, 4)
                    }
                } header: {
                    Text("Sessions by Time of Day")
                }
            }
            
            // Sessions by Day of Week Section
            if !sessionsByDayOfWeek.isEmpty {
                Section {
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 12) {
                            ForEach(sessionsByDayOfWeek.sorted(by: { $0.dayOfWeek < $1.dayOfWeek }), id: \.dayOfWeek) { data in
                                NavigationLink {
                                    FilteredSessionsView(
                                        title: formatDayOfWeekFull(data.dayOfWeek),
                                        sessionIds: data.sessionIds
                                    )
                                } label: {
                                    VStack(spacing: 4) {
                                        Text(formatDayOfWeek(data.dayOfWeek))
                                            .font(.caption)
                                            .fontWeight(.semibold)
                                            .foregroundStyle(AppTheme.emerald)
                                        Text("\(data.count)")
                                            .font(.title3)
                                            .fontWeight(.bold)
                                        Text(data.count == 1 ? "session" : "sessions")
                                            .font(.caption2)
                                            .foregroundStyle(.secondary)
                                    }
                                    .frame(width: 70)
                                    .padding(.vertical, 8)
                                    .background(
                                        RadialGradient(
                                            colors: [AppTheme.emerald.opacity(0.15), AppTheme.emerald.opacity(0.05)],
                                            center: .center,
                                            startRadius: 0,
                                            endRadius: 35
                                        )
                                    )
                                    .clipShape(RoundedRectangle(cornerRadius: 8))
                                }
                                .buttonStyle(.plain)
                            }
                        }
                        .padding(.horizontal, 4)
                    }
                } header: {
                    Text("Sessions by Day of Week")
                }
            }
            
            // Word Cloud Section
            if !topWords.isEmpty {
                Section {
                    ScrollView(.vertical, showsIndicators: true) {
                        LazyVGrid(columns: [
                            GridItem(.flexible()),
                            GridItem(.flexible())
                        ], spacing: 12) {
                            ForEach(Array(topWords.enumerated()), id: \.element.id) { index, wordFreq in
                                VStack(spacing: 6) {
                                    Text(wordFreq.word.capitalized)
                                        .font(.system(size: fontSizeForRank(index), weight: .bold))
                                        .foregroundStyle(colorForRank(index))
                                        .lineLimit(1)
                                        .minimumScaleFactor(0.7)
                                    
                                    Text("\(wordFreq.count)")
                                        .font(.caption)
                                        .fontWeight(.semibold)
                                        .foregroundStyle(.white)
                                        .padding(.horizontal, 10)
                                        .padding(.vertical, 4)
                                        .background(colorForRank(index).gradient)
                                        .clipShape(Capsule())
                                }
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 12)
                                .background(colorForRank(index).opacity(0.08))
                                .clipShape(RoundedRectangle(cornerRadius: 12))
                            }
                        }
                        .padding(.horizontal, 2)
                    }
                    .frame(height: 400)
                } header: {
                    Text("Most Used Words")
                } footer: {
                    Text("Meaningful words from your transcripts")
                }
            }
            
            // Emotional Trends Section (Stats only, no chart)
            if !dailySentiment.isEmpty {
                Section {
                    HStack(spacing: 16) {
                        sentimentStatBox(
                            label: "Positive",
                            count: dailySentiment.filter { $0.sentiment > 0.3 }.count,
                            color: .green
                        )
                        sentimentStatBox(
                            label: "Neutral",
                            count: dailySentiment.filter { abs($0.sentiment) <= 0.3 }.count,
                            color: .gray
                        )
                        sentimentStatBox(
                            label: "Negative",
                            count: dailySentiment.filter { $0.sentiment < -0.3 }.count,
                            color: .red
                        )
                    }
                    .padding(.vertical, 8)
                } header: {
                    Text("Emotional Trends")
                } footer: {
                    Text("Daily sentiment analysis from your journal entries")
                }
            }
            
            // Languages Section
            if !languageDistribution.isEmpty {
                Section {
                    let totalWords = languageDistribution.reduce(0) { $0 + $1.wordCount }
                    
                    ForEach(languageDistribution.prefix(5), id: \.language) { item in
                        let percentage = totalWords > 0 ? (Double(item.wordCount) / Double(totalWords)) * 100 : 0
                        
                        VStack(alignment: .leading, spacing: 4) {
                            HStack {
                                Text(LanguageDetector.displayName(for: item.language))
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                Spacer()
                                Text("\(Int(percentage))%")
                                    .font(.subheadline)
                                    .foregroundStyle(.secondary)
                                    .monospacedDigit()
                            }
                            
                            GeometryReader { geometry in
                                ZStack(alignment: .leading) {
                                    RoundedRectangle(cornerRadius: 4)
                                        .fill(Color.secondary.opacity(0.2))
                                    
                                    RoundedRectangle(cornerRadius: 4)
                                        .fill(languageColor(index: languageDistribution.firstIndex(where: { $0.language == item.language }) ?? 0))
                                        .frame(width: geometry.size.width * (percentage / 100))
                                }
                            }
                            .frame(height: 8)
                        }
                        .padding(.vertical, 4)
                    }
                    
                    if languageDistribution.count > 1 {
                        Text("You speak \(languageDistribution.count) language\(languageDistribution.count == 1 ? "" : "s") in your recordings")
                            .font(.callout)
                            .foregroundStyle(.secondary)
                            .padding(.top, 8)
                    }
                } header: {
                    Text("Languages Spoken")
                } footer: {
                    Text("Distribution of languages in your recordings")
                }
            }
            
            // Settings Sections
            Section {
                VStack(alignment: .leading, spacing: 12) {
                    HStack {
                        Text("Word Cloud Limit")
                        Spacer()
                        Text("\(Int(wordLimit))")
                            .foregroundStyle(.secondary)
                            .monospacedDigit()
                    }
                    
                    Slider(value: $wordLimit, in: 10...200, step: 10) {
                        Text("Word Limit")
                    }
                    .onChange(of: wordLimit) { oldValue, newValue in
                        UserDefaults.standard.set(Int(newValue), forKey: wordLimitKey)
                        coordinator.showSuccess("Word limit updated to \(Int(newValue))")
                        Task {
                            await loadStatistics()
                        }
                    }
                }
                .padding(.vertical, 4)
            } header: {
                Text("Settings")
            } footer: {
                Text("Number of most-used words to display in the Statistics tab.")
            }
            
            Section {
                Picker("Date Format", selection: $dateFormat) {
                    ForEach(dateFormatOptions, id: \.0) { format, example in
                        Text(example).tag(format)
                    }
                }
                .onChange(of: dateFormat) { oldValue, newValue in
                    UserDefaults.standard.rollupDateFormat = newValue
                    coordinator.showSuccess("Date format updated")
                }
                
                Picker("Time Format", selection: $timeFormat) {
                    ForEach(timeFormatOptions, id: \.0) { format, example in
                        Text(example).tag(format)
                    }
                }
                .onChange(of: timeFormat) { oldValue, newValue in
                    UserDefaults.standard.rollupTimeFormat = newValue
                    coordinator.showSuccess("Time format updated")
                }
            } header: {
                Text("Rollup Date & Time Format")
            } footer: {
                Text("Date and time format used in period rollups (hour, day, week, month, year).")
            }
            
            Section {
                NavigationLink(destination: ExcludedWordsView()) {
                    Label {
                        VStack(alignment: .leading, spacing: 2) {
                            Text("Excluded Words")
                            Text("Manage stop words for word cloud")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    } icon: {
                        Image(systemName: "text.badge.xmark")
                            .foregroundStyle(.red)
                    }
                }
            } header: {
                Text("Filters")
            }
        }
        .navigationTitle("Statistics")
        .navigationBarTitleDisplayMode(.inline)
        .overlay {
            if isLoadingStats {
                LoadingView(size: .medium)
            }
        }
        .task {
            wordLimit = Double(UserDefaults.standard.integer(forKey: wordLimitKey))
            if wordLimit == 0 {
                wordLimit = 20
            }
            await loadStatistics()
        }
        .refreshable {
            await loadStatistics()
        }
    }
    
    private func loadStatistics() async {
        isLoadingStats = true
        do {
            // Load key statistics
            longestSession = try await coordinator.fetchLongestSession()
            mostActiveMonth = try await coordinator.fetchMostActiveMonth()
            
            // Load sessions by hour
            sessionsByHour = try await coordinator.fetchSessionsByHour()
            
            // Load sessions by day of week
            sessionsByDayOfWeek = try await coordinator.fetchSessionsByDayOfWeek()
            
            // Load word frequency analysis (all time)
            let transcriptTexts = try await coordinator.fetchTranscriptText(
                startDate: Date.distantPast,
                endDate: Date()
            )
            
            let customExcludedWords: Set<String> = {
                if let savedWords = UserDefaults.standard.stringArray(forKey: "customExcludedWords") {
                    return Set(savedWords)
                }
                return []
            }()
            
            topWords = WordAnalyzer.analyzeWords(
                from: transcriptTexts,
                limit: Int(wordLimit),
                customExcludedWords: customExcludedWords
            )
            
            // Load daily sentiment data (all time)
            dailySentiment = try await coordinator.fetchDailySentiment(from: Date.distantPast, to: Date())
            
            // Load language distribution
            languageDistribution = try await coordinator.fetchLanguageDistribution()
        } catch {
            print("‚ùå [StatisticsView] Failed to load statistics: \(error)")
        }
        isLoadingStats = false
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let hours = Int(duration) / 3600
        let minutes = (Int(duration) % 3600) / 60
        
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        } else {
            return "\(minutes)m"
        }
    }
    
    private func formatMonth(year: Int, month: Int) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM yyyy"
        if let date = Calendar.current.date(from: DateComponents(year: year, month: month)) {
            return formatter.string(from: date)
        }
        return "\(month)/\(year)"
    }
    
    private func formatHour(_ hour: Int) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h a"
        let calendar = Calendar.current
        let date = calendar.date(bySettingHour: hour, minute: 0, second: 0, of: Date()) ?? Date()
        return formatter.string(from: date)
    }
    
    private func formatHourShort(_ hour: Int) -> String {
        if hour == 0 {
            return "12 AM"
        } else if hour < 12 {
            return "\(hour) AM"
        } else if hour == 12 {
            return "12 PM"
        } else {
            return "\(hour - 12) PM"
        }
    }
    
    private func formatDayOfWeek(_ dayOfWeek: Int) -> String {
        let days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        return days[dayOfWeek]
    }
    
    private func formatDayOfWeekFull(_ dayOfWeek: Int) -> String {
        let days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        return days[dayOfWeek]
    }
    
    private func fontSizeForRank(_ rank: Int) -> CGFloat {
        switch rank {
        case 0...2: return 24
        case 3...5: return 20
        case 6...9: return 18
        default: return 16
        }
    }
    
    private func colorForRank(_ rank: Int) -> Color {
        switch rank {
        case 0: return AppTheme.skyBlue
        case 1: return AppTheme.purple
        case 2: return AppTheme.magenta
        case 3: return AppTheme.emerald
        case 4: return AppTheme.lightPurple
        default: return AppTheme.darkPurple
        }
    }
    
    private func sentimentStatBox(label: String, count: Int, color: Color) -> some View {
        VStack(spacing: 8) {
            Text(label)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundStyle(.secondary)
            
            Text("\(count)")
                .font(.title2)
                .fontWeight(.bold)
                .foregroundStyle(color)
            
            Text("days")
                .font(.caption2)
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 12)
        .background(color.opacity(0.1))
        .clipShape(RoundedRectangle(cornerRadius: 12))
    }
    
    private func languageColor(index: Int) -> Color {
        let colors: [Color] = [AppTheme.skyBlue, AppTheme.emerald, AppTheme.purple, AppTheme.magenta, AppTheme.lightPurple]
        return colors[index % colors.count]
    }
}

// MARK: - Data Settings View

struct DataSettingsView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var showDataManagement = false
    @State private var storageUsed: String = "Calculating..."
    
    var body: some View {
        List {
            Section {
                NavigationLink(destination: HistoricalDataView()) {
                    Label {
                        VStack(alignment: .leading, spacing: 2) {
                            Text("Historical Data")
                            Text("View and manage data by year")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    } icon: {
                        Image(systemName: "clock.arrow.circlepath")
                            .foregroundStyle(.blue)
                    }
                }
            } header: {
                Text("Browse Data")
            } footer: {
                Text("The Overview tab always shows the current year. Use Historical Data to browse previous years.")
            }
            
            Section {
                Button {
                    showDataManagement = true
                } label: {
                    Label {
                        VStack(alignment: .leading, spacing: 2) {
                            Text("Export & Backup")
                            Text("Export your data or create backups")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    } icon: {
                        Image(systemName: "square.and.arrow.up")
                            .foregroundStyle(.green)
                    }
                }
                .foregroundStyle(.primary)
            } header: {
                Text("Data Management")
            }
            
            Section {
                HStack {
                    Label("Storage Used", systemImage: "internaldrive")
                    Spacer()
                    Text(storageUsed)
                        .foregroundStyle(.secondary)
                }
            } header: {
                Text("Storage")
            } footer: {
                Text("Includes recordings, transcripts, and AI models.")
            }
        }
        .navigationTitle("Data")
        .navigationBarTitleDisplayMode(.inline)
        .sheet(isPresented: $showDataManagement) {
            DataManagementView()
                .environmentObject(coordinator)
        }
        .task {
            await calculateStorage()
        }
    }
    
    private func calculateStorage() async {
        // Calculate total storage used by app
        let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first
        
        if let url = documentsURL {
            let size = directorySize(url: url)
            let formatter = ByteCountFormatter()
            formatter.allowedUnits = [.useMB, .useGB]
            formatter.countStyle = .file
            storageUsed = formatter.string(fromByteCount: Int64(size))
        }
    }
    
    private func directorySize(url: URL) -> Int {
        let fileManager = FileManager.default
        var totalSize = 0
        
        if let enumerator = fileManager.enumerator(at: url, includingPropertiesForKeys: [.fileSizeKey], options: [.skipsHiddenFiles]) {
            for case let fileURL as URL in enumerator {
                if let fileSize = try? fileURL.resourceValues(forKeys: [.fileSizeKey]).fileSize {
                    totalSize += fileSize
                }
            }
        }
        
        return totalSize
    }
}

// MARK: - Privacy Settings View

struct PrivacySettingsView: View {
    var body: some View {
        List {
            Section {
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Label("Transcription", systemImage: "waveform")
                        Spacer()
                        Text("On-Device")
                            .font(.caption)
                            .fontWeight(.semibold)
                            .foregroundStyle(.green)
                    }
                    Text("100% local, uses Apple Speech framework")
                        .font(.caption2)
                        .foregroundStyle(.secondary)
                        .padding(.leading, 32)
                }
                
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Label("AI Summaries", systemImage: "sparkles")
                        Spacer()
                        Text("User-Controlled")
                            .font(.caption)
                            .fontWeight(.semibold)
                            .foregroundStyle(.blue)
                    }
                    Text("Uses your API keys (OpenAI/Anthropic) or on-device fallback")
                        .font(.caption2)
                        .foregroundStyle(.secondary)
                        .padding(.leading, 32)
                }
                
                HStack {
                    Label("iCloud Sync", systemImage: "icloud.slash")
                    Spacer()
                    Text("Disabled")
                        .foregroundStyle(.secondary)
                }
                
                HStack {
                    Label("Analytics", systemImage: "chart.bar.xaxis")
                    Spacer()
                    Text("None")
                        .foregroundStyle(.secondary)
                }
            } header: {
                Text("Privacy Status")
            } footer: {
                Text("Transcription always happens on-device. AI summaries use external APIs only if you provide API keys, otherwise on-device processing.")
            }
            
            Section {
                NavigationLink(destination: PrivacyPolicyView()) {
                    Label("Privacy Policy", systemImage: "doc.text")
                }
            }
        }
        .navigationTitle("Privacy")
        .navigationBarTitleDisplayMode(.inline)
    }
}

struct ExcludedWordsView: View {
    @Environment(\.dismiss) private var dismiss
    private let excludedWords = Array(StopWords.all).sorted()
    @State private var customWordsText: String = ""
    @State private var customWords: Set<String> = []
    @State private var savedCustomWordsText: String = "" // Track saved state
    @State private var showUnsavedAlert = false
    @FocusState private var isTextFieldFocused: Bool
    
    private let customWordsKey = "customExcludedWords"
    
    private var hasUnsavedChanges: Bool {
        // Check if text field has content that differs from saved state
        let currentText = customWordsText.trimmingCharacters(in: .whitespacesAndNewlines)
        return !currentText.isEmpty && currentText != savedCustomWordsText
    }
    
    var body: some View {
        List {
            Section {
                VStack(alignment: .leading, spacing: 12) {
                    Text("Common words that are filtered out from the word frequency analysis to focus on meaningful content.")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                    
                    HStack {
                        Image(systemName: "info.circle.fill")
                            .foregroundStyle(.blue)
                        Text("\(excludedWords.count) words excluded")
                            .font(.caption)
                            .fontWeight(.semibold)
                    }
                    .padding(.vertical, 4)
                }
            } header: {
                Text("About Excluded Words")
            }
            
            Section {
                ForEach(categoryGroups, id: \.category) { group in
                    DisclosureGroup {
                        FlowLayout(spacing: 8) {
                            ForEach(group.words, id: \.self) { word in
                                Text(word)
                                    .font(.caption)
                                    .padding(.horizontal, 10)
                                    .padding(.vertical, 6)
                                    .background(.gray.opacity(0.15))
                                    .clipShape(Capsule())
                            }
                        }
                        .padding(.vertical, 8)
                    } label: {
                        HStack {
                            Image(systemName: group.icon)
                                .foregroundStyle(group.color)
                                .frame(width: 24)
                            Text(group.category)
                                .fontWeight(.medium)
                            Spacer()
                            Text("\(group.words.count)")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    }
                }
            } header: {
                Text("Word Categories")
            }
            
            // Display saved custom words
            if !customWords.isEmpty {
                Section {
                    FlowLayout(spacing: 8) {
                        ForEach(Array(customWords).sorted(), id: \.self) { word in
                            HStack(spacing: 6) {
                                Text(word)
                                    .font(.caption)
                                    .fontWeight(.medium)
                                Button {
                                    withAnimation {
                                        removeCustomWord(word)
                                    }
                                } label: {
                                    Image(systemName: "xmark.circle.fill")
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                }
                                .buttonStyle(.plain)
                            }
                            .padding(.horizontal, 10)
                            .padding(.vertical, 6)
                            .background(.purple.opacity(0.15))
                            .clipShape(Capsule())
                        }
                    }
                    .padding(.vertical, 8)
                } header: {
                    HStack {
                        Text("Your Custom Words")
                        Spacer()
                        Text("\(customWords.count)")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                } footer: {
                    Text("Tap the X to remove a custom word")
                        .font(.caption2)
                }
            }
            
            Section {
                VStack(alignment: .leading, spacing: 12) {
                    Text("Add your own words to exclude")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    
                    TextField("Enter words separated by commas", text: $customWordsText)
                        .textFieldStyle(.roundedBorder)
                        .focused($isTextFieldFocused)
                        .autocorrectionDisabled()
                        .textInputAutocapitalization(.never)
                    
                    Button("Save Custom Words") {
                        // Dismiss keyboard first, then save after a brief delay
                        isTextFieldFocused = false
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                            saveCustomWords()
                        }
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(AppTheme.purple)
                    .disabled(customWordsText.isEmpty)
                    
                    Text("Words will be converted to lowercase and trimmed. Separate multiple words with commas.")
                        .font(.caption2)
                        .foregroundStyle(.secondary)
                }
                .padding(.vertical, 4)
            } header: {
                Text("Add Custom Words")
            }
        }
        .navigationTitle("Excluded Words")
        .navigationBarTitleDisplayMode(.inline)
        .navigationBarBackButtonHidden(hasUnsavedChanges)
        .toolbar {
            if hasUnsavedChanges {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button {
                        showUnsavedAlert = true
                    } label: {
                        HStack(spacing: 4) {
                            Image(systemName: "chevron.left")
                            Text("Back")
                        }
                    }
                }
            }
        }
        .alert("Unsaved Custom Words", isPresented: $showUnsavedAlert) {
            Button("Save and Go Back", role: .none) {
                saveCustomWords()
                dismiss()
            }
            Button("Discard", role: .destructive) {
                customWordsText = savedCustomWordsText
                dismiss()
            }
            Button("Cancel", role: .cancel) { }
        } message: {
            Text("You have unsaved words in the text field. Do you want to save them before going back?")
        }
        .onAppear {
            loadCustomWords()
        }
    }
    
    private func loadCustomWords() {
        if let savedWords = UserDefaults.standard.stringArray(forKey: customWordsKey) {
            customWords = Set(savedWords)
            // Keep track of saved state but don't populate text field
            savedCustomWordsText = savedWords.sorted().joined(separator: ", ")
        }
    }
    
    private func saveCustomWords() {
        // Parse comma-separated words
        let newWords = customWordsText
            .split(separator: ",")
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines).lowercased() }
            .filter { !$0.isEmpty && $0.count >= 2 }
        
        // Add new words to existing set (don't replace)
        customWords.formUnion(newWords)
        
        // Save to UserDefaults
        UserDefaults.standard.set(Array(customWords), forKey: customWordsKey)
        
        // Update saved state and clear text field
        savedCustomWordsText = Array(customWords).sorted().joined(separator: ", ")
        customWordsText = ""
    }
    
    private func removeCustomWord(_ word: String) {
        customWords.remove(word)
        UserDefaults.standard.set(Array(customWords), forKey: customWordsKey)
        // Update saved state (text field should remain empty)
        savedCustomWordsText = Array(customWords).sorted().joined(separator: ", ")
    }
    
    private var categoryGroups: [WordCategory] {
        // Use categories from constants file (single source of truth)
        StopWords.categories.map { category in
            WordCategory(
                category: category.name,
                icon: category.icon,
                color: category.color,
                words: Array(category.words).sorted()
            )
        }
    }
}

struct WordCategory {
    let category: String
    let icon: String
    let color: Color
    let words: [String]
}

// Simple flow layout for wrapping words
struct FlowLayout: Layout {
    var spacing: CGFloat = 8
    
    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
        let result = FlowResult(
            in: proposal.replacingUnspecifiedDimensions().width,
            subviews: subviews,
            spacing: spacing
        )
        return result.size
    }
    
    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        let result = FlowResult(
            in: bounds.width,
            subviews: subviews,
            spacing: spacing
        )
        for (index, subview) in subviews.enumerated() {
            subview.place(at: CGPoint(x: bounds.minX + result.frames[index].minX, y: bounds.minY + result.frames[index].minY), proposal: .unspecified)
        }
    }
    
    struct FlowResult {
        var frames: [CGRect] = []
        var size: CGSize = .zero
        
        init(in maxWidth: CGFloat, subviews: Subviews, spacing: CGFloat) {
            var x: CGFloat = 0
            var y: CGFloat = 0
            var lineHeight: CGFloat = 0
            
            for subview in subviews {
                let size = subview.sizeThatFits(.unspecified)
                
                if x + size.width > maxWidth && x > 0 {
                    x = 0
                    y += lineHeight + spacing
                    lineHeight = 0
                }
                
                frames.append(CGRect(x: x, y: y, width: size.width, height: size.height))
                lineHeight = max(lineHeight, size.height)
                x += size.width + spacing
            }
            
            self.size = CGSize(width: maxWidth, height: y + lineHeight)
        }
    }
}

struct PrivacyPolicyView: View {
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 20) {
                Text("Privacy First")
                    .font(.title.bold())
                
                VStack(alignment: .leading, spacing: 12) {
                    PrivacyPoint(
                        icon: "waveform",
                        title: "Transcription: 100% On-Device",
                        description: "All audio recording and speech-to-text happens locally using Apple's Speech framework. Zero network calls."
                    )
                    
                    PrivacyPoint(
                        icon: "sparkles",
                        title: "AI Summaries: User-Controlled",
                        description: "Uses OpenAI or Anthropic APIs only if you provide your own API keys. Otherwise, on-device processing with Apple Intelligence or Basic summaries."
                    )
                    
                    PrivacyPoint(
                        icon: "network",
                        title: "Network Calls: Transparent",
                        description: "With API keys: Connects to OpenAI (api.openai.com) or Anthropic (api.anthropic.com) using YOUR keys. Without keys: 100% offline."
                    )
                    
                    PrivacyPoint(
                        icon: "eye.slash.fill",
                        title: "No Tracking",
                        description: "We don't collect analytics, telemetry, or usage data. Your API keys are stored securely in Keychain."
                    )
                    
                    PrivacyPoint(
                        icon: "square.and.arrow.up",
                        title: "Your Data, Your Control",
                        description: "Export or delete your data anytime. Audio files and transcripts never leave your device."
                    )
                }
            }
            .padding()
        }
        .navigationTitle("Privacy Policy")
        .navigationBarTitleDisplayMode(.inline)
    }
}

struct PrivacyPoint: View {
    @Environment(\.colorScheme) var colorScheme
    let icon: String
    let title: String
    let description: String
    
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(.blue)
                .frame(width: 32)
            
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.headline)
                
                Text(description)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .fill(AppTheme.cardGradient(for: colorScheme))
                .allowsHitTesting(false)
        )
        .cornerRadius(12)
    }
}

// MARK: - Recording Detail View

struct RecordingDetailView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @Environment(\.colorScheme) var colorScheme
    let recording: AudioChunk
    
    @State private var transcriptSegments: [TranscriptSegment] = []
    @State private var isLoading = true
    @State private var loadError: String?
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 24) {
                // Recording Info Card
                VStack(alignment: .leading, spacing: 12) {
                    Text("Recording Details")
                        .font(.headline)
                    
                    InfoRow(label: "Date", value: recording.startTime.formatted(date: .abbreviated, time: .shortened))
                    InfoRow(label: "Duration", value: formatDuration(recording.duration))
                    InfoRow(label: "Format", value: "\(recording.sampleRate) Hz")
                }
                .padding()
                .background(Color(.secondarySystemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(AppTheme.cardGradient(for: colorScheme))
                        .allowsHitTesting(false)
                )
                .cornerRadius(12)
                
                // Playback Controls
                VStack(spacing: 16) {
                    // Waveform placeholder
                    RoundedRectangle(cornerRadius: 8)
                        .fill(Color(.tertiarySystemBackground))
                        .frame(height: 60)
                        .overlay {
                            if coordinator.audioPlayback.currentlyPlayingURL == recording.fileURL {
                                // Show progress
                                GeometryReader { geometry in
                                    let progress = coordinator.audioPlayback.duration > 0 
                                        ? coordinator.audioPlayback.currentTime / coordinator.audioPlayback.duration 
                                        : 0
                                    
                                    HStack(spacing: 0) {
                                        Rectangle()
                                            .fill(Color.blue.opacity(0.3))
                                            .frame(width: geometry.size.width * progress)
                                        Spacer()
                                    }
                                }
                            }
                        }
                    
                    // Play/Pause Button
                    Button {
                        playRecording()
                    } label: {
                        HStack(spacing: 12) {
                            Image(systemName: isPlaying ? "pause.circle.fill" : "play.circle.fill")
                                .font(.system(size: 32))
                                .foregroundStyle(
                                    LinearGradient(
                                        colors: [AppTheme.purple, AppTheme.magenta],
                                        startPoint: .leading,
                                        endPoint: .trailing
                                    )
                                )
                            
                            VStack(alignment: .leading, spacing: 4) {
                                if isPlaying {
                                    Text("\(formatTime(coordinator.audioPlayback.currentTime)) / \(formatTime(coordinator.audioPlayback.duration))")
                                        .font(.body)
                                        .fontWeight(.medium)
                                        .foregroundStyle(.primary)
                                } else {
                                    Text("Tap to Play")
                                        .font(.body)
                                        .fontWeight(.semibold)
                                        .foregroundStyle(.primary)
                                }
                                
                                Text(isPlaying ? "Playing..." : "Start playback")
                                    .font(.caption)
                                    .foregroundStyle(.secondary)
                            }
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .font(.body)
                                .foregroundStyle(.tertiary)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(16)
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(Color(.secondarySystemBackground))
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(
                                    LinearGradient(
                                        colors: [AppTheme.purple.opacity(0.3), AppTheme.magenta.opacity(0.2)],
                                        startPoint: .leading,
                                        endPoint: .trailing
                                    ),
                                    lineWidth: 2
                                )
                        )
                        .contentShape(Rectangle())
                    }
                    .buttonStyle(.plain)
                }
                .padding()
                .background(Color(.secondarySystemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(AppTheme.cardGradient(for: colorScheme))
                        .allowsHitTesting(false)
                )
                .cornerRadius(12)
                
                // Transcription Section
                VStack(alignment: .leading, spacing: 12) {
                    Text("Transcription")
                        .font(.headline)
                    
                    if isLoading {
                        ProgressView("Loading transcription...")
                            .frame(maxWidth: .infinity)
                            .padding()
                    } else if let error = loadError {
                        Text("Error: \(error)")
                            .foregroundStyle(.red)
                            .font(.subheadline)
                            .padding()
                    } else if transcriptSegments.isEmpty {
                        Text("No transcription available")
                            .foregroundStyle(.secondary)
                            .padding()
                    } else {
                        VStack(alignment: .leading, spacing: 8) {
                            ForEach(transcriptSegments, id: \.id) { segment in
                                Text(segment.text)
                                    .font(.body)
                                    .padding(.vertical, 4)
                            }
                        }
                        .padding()
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding()
                .background(Color(.secondarySystemBackground))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(AppTheme.cardGradient(for: colorScheme))
                        .allowsHitTesting(false)
                )
                .cornerRadius(12)
            }
            .padding()
        }
        .navigationTitle("Recording")
        .navigationBarTitleDisplayMode(.inline)
        .task {
            await loadTranscription()
        }
    }
    
    private var isPlaying: Bool {
        coordinator.audioPlayback.currentlyPlayingURL == recording.fileURL && coordinator.audioPlayback.isPlaying
    }
    
    private func playRecording() {
        if coordinator.audioPlayback.currentlyPlayingURL == recording.fileURL {
            coordinator.audioPlayback.togglePlayPause()
        } else {
            Task {
                do {
                    try await coordinator.audioPlayback.play(url: recording.fileURL)
                } catch {
                    loadError = "Could not play recording: \(error.localizedDescription)"
                }
            }
        }
    }
    
    private func loadTranscription() async {
        isLoading = true
        loadError = nil
        
        do {
            transcriptSegments = try await coordinator.fetchTranscript(for: recording.id)
            print("üìÑ [RecordingDetailView] Loaded \(transcriptSegments.count) transcript segments")
            
            // Debug: print the first segment if available
            if let first = transcriptSegments.first {
                print("üìÑ [RecordingDetailView] First segment: '\(first.text)'")
            }
        } catch {
            print("‚ùå [RecordingDetailView] Failed to load transcription: \(error)")
            loadError = error.localizedDescription
        }
        
        isLoading = false
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let minutes = Int(duration) / 60
        let seconds = Int(duration) % 60
        if minutes > 0 {
            return "\(minutes)m \(seconds)s"
        } else {
            return "\(seconds)s"
        }
    }
    
    private func formatTime(_ time: TimeInterval) -> String {
        let minutes = Int(time) / 60
        let seconds = Int(time) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
}

// MARK: - Transcript Chunk View

struct TranscriptChunkView: View {
    let chunkIndex: Int
    let segments: [TranscriptSegment]
    let session: RecordingSession
    let isCurrentChunk: Bool
    let chunkId: UUID?
    let coordinator: AppCoordinator
    let isEdited: Bool  // Track if this chunk was edited
    let onSeekToChunk: () -> Void
    let onTextEdited: (UUID, String) -> Void
    
    @State private var isEditing = false
    @State private var editedText: String = ""
    @FocusState private var isTextFocused: Bool
    
    private var combinedText: String {
        segments.map { $0.text }.joined(separator: " ")
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            // Action buttons row at top right
            HStack {
                // Left side: Part label for multi-chunk, or edited badge
                if session.chunkCount > 1 {
                    HStack(spacing: 6) {
                        Text("Part \(chunkIndex + 1)")
                            .font(.caption)
                            .foregroundStyle(isCurrentChunk ? .blue : .secondary)
                            .fontWeight(isCurrentChunk ? .semibold : .regular)
                        
                        if let chunkId = chunkId {
                            transcriptionStatusBadge(for: chunkId)
                        }
                        
                        if isEdited {
                            HStack(spacing: 2) {
                                Image(systemName: "pencil.circle.fill")
                                    .font(.caption2)
                                Text("Edited")
                                    .font(.caption2)
                            }
                            .foregroundStyle(.orange)
                        }
                    }
                } else if isEdited {
                    HStack(spacing: 2) {
                        Image(systemName: "pencil.circle.fill")
                            .font(.caption2)
                        Text("Edited")
                            .font(.caption2)
                    }
                    .foregroundStyle(.orange)
                }
                
                Spacer()
                
                // Action buttons - compact
                if !isEditing && !combinedText.isEmpty {
                    HStack(spacing: 8) {
                        Button {
                            UIPasteboard.general.string = combinedText
                            coordinator.showSuccess("Copied")
                        } label: {
                            Image(systemName: "doc.on.doc")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                        .buttonStyle(.plain)
                        
                        Button {
                            editedText = combinedText
                            isEditing = true
                            isTextFocused = true
                        } label: {
                            HStack(spacing: 2) {
                                Image(systemName: "pencil")
                                Text("Edit")
                            }
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundStyle(.blue)
                        }
                        .buttonStyle(.plain)
                    }
                }
            }
            
            // Content
            chunkContent
        }
        .padding(10)
        .background(chunkBackground)
        .cornerRadius(8)
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .stroke(chunkBorderColor, lineWidth: 2)
        )
        .onTapGesture {
            if !isEditing {
                onSeekToChunk()
            }
        }
        .animation(.easeInOut(duration: 0.3), value: isCurrentChunk)
        .animation(.easeInOut(duration: 0.3), value: isEdited)
    }
    
    private var chunkBackground: Color {
        if isEdited {
            return Color.orange.opacity(0.08)
        } else if isCurrentChunk {
            return Color.blue.opacity(0.1)
        } else {
            return Color.clear
        }
    }
    
    private var chunkBorderColor: Color {
        if isEdited {
            return Color.orange.opacity(0.5)
        } else if isCurrentChunk {
            return Color.blue.opacity(0.5)
        } else {
            return Color.clear
        }
    }
    
    @ViewBuilder
    private func transcriptionStatusBadge(for chunkId: UUID) -> some View {
        Group {
            if coordinator.transcribingChunkIds.contains(chunkId) {
                HStack(spacing: 4) {
                    ProgressView()
                        .scaleEffect(0.6)
                    Text("Transcribing...")
                        .font(.caption2)
                        .fontWeight(.medium)
                }
                .foregroundStyle(.blue)
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(
                    RadialGradient(
                        colors: [Color.blue.opacity(0.2), Color.blue.opacity(0.05)],
                        center: .center,
                        startRadius: 5,
                        endRadius: 20
                    )
                )
                .clipShape(Capsule())
            } else if coordinator.transcribedChunkIds.contains(chunkId) {
                HStack(spacing: 4) {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.caption2)
                    Text("Done")
                        .font(.caption2)
                        .fontWeight(.medium)
                }
                .foregroundColor(.green)
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(
                    RadialGradient(
                        colors: [Color.green.opacity(0.2), Color.green.opacity(0.05)],
                        center: .center,
                        startRadius: 5,
                        endRadius: 20
                    )
                )
                .clipShape(Capsule())
            } else if coordinator.failedChunkIds.contains(chunkId) {
                HStack(spacing: 4) {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .font(.caption2)
                    Text("Failed")
                        .font(.caption2)
                        .fontWeight(.medium)
                }
                .foregroundColor(.orange)
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(
                    RadialGradient(
                        colors: [Color.orange.opacity(0.2), Color.orange.opacity(0.05)],
                        center: .center,
                        startRadius: 5,
                        endRadius: 20
                    )
                )
                .clipShape(Capsule())
            }
        }
    }
    
    @ViewBuilder
    private var chunkContent: some View {
        if let chunkId = chunkId, coordinator.failedChunkIds.contains(chunkId) {
            VStack(spacing: 12) {
                Text("Transcription failed for this part")
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
                
                Button {
                    Task {
                        await coordinator.retryTranscription(chunkId: chunkId)
                    }
                } label: {
                    HStack(spacing: 6) {
                        Image(systemName: "arrow.clockwise")
                        Text("Retry Transcription")
                    }
                    .font(.subheadline)
                    .fontWeight(.medium)
                }
                .buttonStyle(.borderedProminent)
                .tint(AppTheme.magenta)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
        } else if isEditing {
            VStack(alignment: .leading, spacing: 12) {
                TextEditor(text: $editedText)
                    .font(.body)
                    .frame(minHeight: 200, maxHeight: 400)
                    .padding(12)
                    .background(Color(.tertiarySystemBackground))
                    .cornerRadius(12)
                    .focused($isTextFocused)
                    .scrollContentBackground(.hidden)
                
                HStack(spacing: 12) {
                    Button {
                        isEditing = false
                        editedText = ""
                    } label: {
                        Text("Cancel")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundStyle(.secondary)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 12)
                            .background(Color(.tertiarySystemBackground))
                            .cornerRadius(10)
                    }
                    .buttonStyle(.plain)
                    
                    Button {
                        saveEdit()
                    } label: {
                        Text("Save")
                            .font(.subheadline)
                            .fontWeight(.semibold)
                            .foregroundStyle(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 12)
                            .background(editedText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? Color.gray : Color.blue)
                            .cornerRadius(10)
                    }
                    .buttonStyle(.plain)
                    .disabled(editedText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                }
            }
        } else {
            // Selectable text - user can select and copy individual words
            Text(combinedText)
                .font(.body)
                .foregroundStyle(isCurrentChunk ? .primary : .secondary)
                .textSelection(.enabled)
                .onTapGesture {
                    onSeekToChunk()
                }
        }
    }
    
    private func saveEdit() {
        let trimmedText = editedText.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedText.isEmpty, let firstSegment = segments.first else {
            isEditing = false
            return
        }
        
        // Save the edited text to the first segment (we combine all segments into one for simplicity)
        onTextEdited(firstSegment.id, trimmedText)
        isEditing = false
        editedText = ""
    }
}

// MARK: - Session Detail View

struct SessionDetailView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @Environment(\.colorScheme) var colorScheme
    let session: RecordingSession
    
    @State private var transcriptSegments: [TranscriptSegment] = []
    @State private var isLoading = true
    @State private var loadError: String?
    @State private var currentlyPlayingChunkIndex: Int?
    @State private var playbackUpdateTimer: Timer?
    @State private var forceUpdateTrigger = false
    @State private var isTranscriptionComplete = false
    @State private var transcriptionCheckTimer: Timer?
    @State private var sessionSummary: Summary?
    @State private var summaryLoadError: String?
    @State private var scrubbedTime: TimeInterval = 0
    
    // Session metadata
    @State private var sessionTitle: String = ""
    @State private var sessionNotes: String = ""
    @State private var initialSessionNotes: String = ""  // Track initial notes to detect changes
    @State private var isFavorite: Bool = false
    @State private var isEditingTitle: Bool = false
    @State private var isEditingNotes: Bool = false
    
    // Transcript editing
    @State private var editingSegmentId: UUID?
    @State private var editedText: String = ""
    @State private var transcriptWasEdited: Bool = false
    @State private var editedChunkIds: Set<UUID> = []  // Track which chunks were edited
    @State private var isRegeneratingSummary: Bool = false
    @FocusState private var isTextFieldFocused: Bool
    
    // AI Generation progress
    @State private var generationProgress: Double = 0.0
    @State private var generationPhase: String = ""
    @State private var showGenerationOverlay = false
    @State private var activeEngineForGeneration: EngineTier?
    @State private var showRegenerateWithNotesAlert: Bool = false
    @State private var notesWereAppended: Bool = false
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 24) {
                // Session Title Section (Editable)
                sessionTitleSection
                
                // Transcription Processing Banner
                processingBannerSection
                
                // Session Info Card
                sessionInfoSection
                
                // Playback Controls
                playbackControlsSection
                
                // Personal Notes Section (moved here from bottom)
                personalNotesSection
                
                // Transcription Section
                transcriptionSection
                
                // Session Summary Section (if available or error)
                if let summary = sessionSummary {
                    sessionSummarySection(summary: summary)
                } else if let error = summaryLoadError {
                    sessionSummaryErrorSection(error: error)
                } else if isTranscriptionComplete {
                    sessionSummaryPlaceholderSection
                }
            }
            .padding()
        }
        .navigationTitle(sessionTitle.isEmpty ? "Recording" : sessionTitle)
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .topBarTrailing) {
                toolbarButtons
            }
        }
        .task {
            await loadSessionMetadata()
            await loadTranscription()
            await loadSessionSummary()
            checkTranscriptionStatus()
        }
        .onAppear {
            startPlaybackUpdateTimer()
            startTranscriptionCheckTimer()
        }
        .onDisappear {
            stopPlaybackUpdateTimer()
            stopTranscriptionCheckTimer()
            if isPlayingThisSession {
                coordinator.audioPlayback.stop()
            }
        }
        .overlay {
            if showGenerationOverlay {
                aiGenerationOverlay
            }
        }
        .alert("Regenerate Summary with Notes?", isPresented: $showRegenerateWithNotesAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Remove Notes") {
                Task {
                    notesWereAppended = false
                    await regenerateSummary()
                }
            }
            Button("Re-append Notes") {
                Task {
                    await regenerateSummary(reappendNotes: true)
                }
            }
        } message: {
            Text("Your notes are currently appended to the summary. Would you like to regenerate and re-append them, or remove them?")
        }
    }
    
    // MARK: - Processing Banner
    
    @ViewBuilder
    private var processingBannerSection: some View {
        if !isTranscriptionComplete {
            let pendingCount = session.chunkCount - transcriptSegments.map({ $0.audioChunkID }).uniqueCount
            HStack(spacing: 12) {
                ProgressView()
                    .tint(AppTheme.purple)
                    .scaleEffect(0.8)
                
                VStack(alignment: .leading, spacing: 2) {
                    Text("Processing Transcription...")
                        .font(.subheadline)
                        .fontWeight(.medium)
                    Text("\(pendingCount) of \(session.chunkCount) chunks pending")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                
                Spacer()
                
                Button {
                    Task { await refreshSession() }
                } label: {
                    Image(systemName: "arrow.clockwise")
                        .font(.body)
                        .foregroundStyle(AppTheme.purple)
                }
                .buttonStyle(.borderless)
            }
            .padding()
            .background(
                RadialGradient(
                    colors: [AppTheme.purple.opacity(0.15), AppTheme.purple.opacity(0.05)],
                    center: .center,
                    startRadius: 0,
                    endRadius: 100
                )
            )
            .cornerRadius(12)
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(AppTheme.purple.opacity(0.3), lineWidth: 1)
            )
        }
    }
    
    // MARK: - Session Info Section
    
    private var sessionInfoSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Session Details")
                .font(.headline)
            
            InfoRow(label: "Date", value: session.startTime.formatted(date: .abbreviated, time: .shortened))
            InfoRow(label: "Total Duration", value: formatDuration(session.totalDuration))
            InfoRow(label: "Parts", value: "\(session.chunkCount) chunk\(session.chunkCount == 1 ? "" : "s")")
            
            if !transcriptSegments.isEmpty {
                let wordCount = transcriptSegments.reduce(0) { $0 + $1.text.split(separator: " ").count }
                InfoRow(label: "Word Count", value: "\(wordCount) words")
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .fill(AppTheme.cardGradient(for: colorScheme))
                .allowsHitTesting(false)
        )
        .cornerRadius(12)
    }
    
    // MARK: - Toolbar Buttons
    
    private var toolbarButtons: some View {
        HStack(spacing: 16) {
            Button {
                Task {
                    do {
                        isFavorite = try await coordinator.toggleSessionFavorite(sessionId: session.sessionId)
                    } catch {
                        print("‚ùå Failed to toggle favorite: \(error)")
                    }
                }
            } label: {
                Image(systemName: isFavorite ? "star.fill" : "star")
                    .foregroundStyle(isFavorite ? .yellow : .secondary)
            }
            
            ShareLink(item: transcriptText) {
                Image(systemName: "square.and.arrow.up")
            }
            .disabled(transcriptSegments.isEmpty)
        }
    }
    
    // MARK: - Playback Controls Section
    
    private var playbackControlsSection: some View {
        VStack(spacing: 16) {
            scrubberSlider
            timeDisplayRow
            playPauseButton
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .fill(AppTheme.cardGradient(for: colorScheme))
                .allowsHitTesting(false)
        )
        .cornerRadius(12)
    }
    
    private var waveformView: some View {
        Canvas { canvasContext, size in
            let centerY = size.height / 2
            let barCount = 80
            let barWidth = size.width / CGFloat(barCount)
            let maxBarHeight = size.height * 0.8
            
            // Calculate amplitude for each bar based on transcript segments
            let totalDuration = session.totalDuration
            
            for i in 0..<barCount {
                let barStartTime = (Double(i) / Double(barCount)) * totalDuration
                let barEndTime = (Double(i + 1) / Double(barCount)) * totalDuration
                
                // Check if any transcript segments overlap with this bar's time range
                var hasContent = false
                for segment in transcriptSegments {
                    let segmentStart = segment.startTime
                    let segmentEnd = segment.startTime + (segment.duration ?? 1.0)
                    
                    if (segmentStart <= barEndTime && segmentEnd >= barStartTime) {
                        hasContent = true
                        break
                    }
                }
                
                // Calculate bar height (tall where speech exists, short elsewhere)
                let barHeight: CGFloat
                if hasContent {
                    // Add variation for visual interest
                    let variation = sin(Double(i) * 0.5) * 0.3 + 0.7
                    barHeight = maxBarHeight * CGFloat(variation)
                } else {
                    barHeight = 4.0 // Minimal height for silence
                }
                
                let x = CGFloat(i) * barWidth
                let y = centerY - barHeight / 2
                
                let barRect = CGRect(x: x, y: y, width: max(barWidth - 1, 1), height: barHeight)
                let barPath = Path(roundedRect: barRect, cornerRadius: barWidth / 2)
                
                // Color based on playback state
                let color: Color
                if isPlayingThisSession && coordinator.audioPlayback.isPlaying {
                    let progress = totalDuration > 0 ? totalElapsedTime / totalDuration : 0
                    let barProgress = Double(i) / Double(barCount)
                    color = barProgress <= progress ? AppTheme.magenta : AppTheme.purple.opacity(0.5)
                } else {
                    color = AppTheme.purple.opacity(0.4)
                }
                
                canvasContext.fill(barPath, with: .color(color))
            }
            
            // Draw playhead indicator if playing
            if isPlayingThisSession {
                let progress = session.totalDuration > 0 ? totalElapsedTime / session.totalDuration : 0
                let playheadX = size.width * progress
                
                let playheadPath = Path { path in
                    path.move(to: CGPoint(x: playheadX, y: 0))
                    path.addLine(to: CGPoint(x: playheadX, y: size.height))
                }
                
                canvasContext.stroke(playheadPath, with: .color(AppTheme.magenta), lineWidth: 3)
            }
        }
        .frame(height: 100)
    }
    
    private var scrubberSlider: some View {
        // Force slider to update by using forceUpdateTrigger
        let _ = forceUpdateTrigger
        
        return Slider(
            value: Binding(
                get: { 
                    let value = isPlayingThisSession ? totalElapsedTime : scrubbedTime
                    return value
                },
                set: { newValue in
                    if isPlayingThisSession {
                        seekToTotalTime(newValue)
                    } else {
                        scrubbedTime = newValue
                    }
                }
            ),
            in: 0...max(session.totalDuration, 0.1)
        )
        .tint(AppTheme.purple)
    }
    
    private var timeDisplayRow: some View {
        HStack {
            Text(formatTime(isPlayingThisSession ? totalElapsedTime : scrubbedTime))
                .font(.caption)
                .foregroundStyle(.secondary)
                .monospacedDigit()
            
            Spacer()
            
            if isPlayingThisSession, let currentURL = coordinator.audioPlayback.currentlyPlayingURL,
               let idx = session.chunks.firstIndex(where: { $0.fileURL == currentURL }) {
                Text("Part \(idx + 1) of \(session.chunkCount)")
                    .font(.caption)
                    .foregroundStyle(AppTheme.purple)
                    .fontWeight(.medium)
            }
            
            Spacer()
            
            Text(formatTime(session.totalDuration))
                .font(.caption)
                .foregroundStyle(.secondary)
                .monospacedDigit()
        }
    }
    
    private var playPauseButton: some View {
        Button { playSession() } label: {
            let isCurrentlyPlaying = isPlayingThisSession && coordinator.audioPlayback.isPlaying
            
            HStack(spacing: 16) {
                // Icon in a circular background
                ZStack {
                    Circle()
                        .fill(AppTheme.purple.opacity(0.15))
                        .frame(width: 56, height: 56)
                    
                    Image(systemName: isCurrentlyPlaying ? "pause.fill" : "play.fill")
                        .font(.system(size: 22, weight: .semibold))
                        .foregroundStyle(AppTheme.purple)
                }
                
                // Text label
                VStack(alignment: .leading, spacing: 4) {
                    if isCurrentlyPlaying {
                        Text("Pause")
                            .font(.headline)
                            .foregroundStyle(.primary)
                    } else if isPlayingThisSession {
                        Text("Resume")
                            .font(.headline)
                            .foregroundStyle(.primary)
                    } else {
                        Text(session.chunkCount > 1 ? "Play All \(session.chunkCount) Parts" : "Play Recording")
                            .font(.headline)
                            .foregroundStyle(.primary)
                    }
                    
                    Text(formatTime(session.totalDuration))
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                
                Spacer()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(.tertiarySystemBackground))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .strokeBorder(AppTheme.purple.opacity(0.2), lineWidth: 1)
            )
        }
        .buttonStyle(.plain)
    }
    
    // MARK: - Transcription Section
    
    private var transcriptionSection: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header - just the title
            Text("Recording Transcript")
                .font(.headline)
                .padding(.horizontal, 16)
                .padding(.vertical, 12)
            
            // Content directly below header
            transcriptionContent
                .padding(.horizontal, 12)
            
            // Action buttons at the bottom (only if there's content)
            if !transcriptSegments.isEmpty {
                HStack(spacing: 12) {
                    Spacer()
                    
                    // Copy all button
                    Button {
                        UIPasteboard.general.string = transcriptText
                        coordinator.showSuccess("Transcript copied")
                    } label: {
                        HStack(spacing: 6) {
                            Image(systemName: "doc.on.doc")
                                .font(.body)
                            Text("Copy All")
                                .fontWeight(.medium)
                        }
                        .font(.subheadline)
                        .foregroundStyle(AppTheme.skyBlue)
                        .padding(.horizontal, 18)
                        .padding(.vertical, 12)
                        .background(
                            RoundedRectangle(cornerRadius: 10)
                                .fill(
                                    RadialGradient(
                                        colors: [AppTheme.skyBlue.opacity(0.15), AppTheme.skyBlue.opacity(0.05)],
                                        center: .center,
                                        startRadius: 0,
                                        endRadius: 50
                                    )
                                )
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: 10)
                                .stroke(
                                    LinearGradient(
                                        colors: [AppTheme.skyBlue.opacity(0.4), AppTheme.skyBlue.opacity(0.3)],
                                        startPoint: .leading,
                                        endPoint: .trailing
                                    ),
                                    lineWidth: 1.5
                                )
                        )
                        .contentShape(Rectangle())
                    }
                    .buttonStyle(.plain)
                    
                    // Share button
                    ShareLink(item: transcriptText) {
                        HStack(spacing: 6) {
                            Image(systemName: "square.and.arrow.up")
                                .font(.body)
                            Text("Share")
                                .fontWeight(.medium)
                        }
                        .font(.subheadline)
                        .foregroundStyle(AppTheme.skyBlue)
                        .padding(.horizontal, 18)
                        .padding(.vertical, 12)
                        .background(
                            RoundedRectangle(cornerRadius: 10)
                                .fill(
                                    RadialGradient(
                                        colors: [AppTheme.skyBlue.opacity(0.15), AppTheme.skyBlue.opacity(0.05)],
                                        center: .center,
                                        startRadius: 0,
                                        endRadius: 50
                                    )
                                )
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: 10)
                                .stroke(
                                    LinearGradient(
                                        colors: [AppTheme.skyBlue.opacity(0.4), AppTheme.purple.opacity(0.3)],
                                        startPoint: .leading,
                                        endPoint: .trailing
                                    ),
                                    lineWidth: 1.5
                                )
                        )
                        .contentShape(Rectangle())
                    }
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 12)
            } else {
                Spacer().frame(height: 12)
            }
        }
        .background(Color(.secondarySystemBackground))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .fill(AppTheme.cardGradient(for: colorScheme))
                .allowsHitTesting(false)
        )
        .cornerRadius(12)
    }
    
    @ViewBuilder
    private var transcriptionContent: some View {
        if isLoading {
            VStack(spacing: 12) {
                ProgressView()
                    .tint(AppTheme.purple)
                Text("Loading transcription...")
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
        } else if let error = loadError {
            Text("Error: \(error)")
                .foregroundStyle(.red)
                .font(.subheadline)
                .padding(.vertical, 8)
        } else if transcriptSegments.isEmpty {
            transcriptionEmptyState
        } else {
            transcriptionSegmentsList
        }
    }
    
    @ViewBuilder
    private var transcriptionEmptyState: some View {
        let chunkIds = Set(session.chunks.map { $0.id })
        let hasTranscribing = !chunkIds.isDisjoint(with: coordinator.transcribingChunkIds)
        let hasFailed = !chunkIds.isDisjoint(with: coordinator.failedChunkIds)
        
        if hasTranscribing {
            ContentUnavailableView(
                "Transcribing Audio...",
                systemImage: "waveform.path",
                description: Text("Your audio is being processed. This may take a moment.")
            )
            .padding(.vertical, 8)
        } else if hasFailed {
            ContentUnavailableView(
                "Transcription Failed",
                systemImage: "exclamationmark.triangle",
                description: Text("Unable to transcribe this recording. Try recording again.")
            )
            .padding(.vertical, 8)
        } else {
            ContentUnavailableView(
                "No Transcript",
                systemImage: "doc.text.slash",
                description: Text("No transcription available for this recording.")
            )
            .padding(.vertical, 8)
        }
    }
    
    private var transcriptionSegmentsList: some View {
        VStack(alignment: .leading, spacing: 12) {
            ForEach(groupedSegmentsByChunk, id: \.chunkIndex) { group in
                let chunkId = session.chunks[safe: group.chunkIndex]?.id
                TranscriptChunkView(
                    chunkIndex: group.chunkIndex,
                    segments: group.segments,
                    session: session,
                    isCurrentChunk: isPlayingThisSession && currentChunkIndex == group.chunkIndex,
                    chunkId: chunkId,
                    coordinator: coordinator,
                    isEdited: chunkId.map { editedChunkIds.contains($0) } ?? false,
                    onSeekToChunk: { seekToChunk(group.chunkIndex) },
                    onTextEdited: { segmentId, newText in
                        if let chunkId = chunkId {
                            editedChunkIds.insert(chunkId)
                        }
                        saveTranscriptEdit(segmentId: segmentId, newText: newText)
                    }
                )
            }
            
            // Show regenerate prompt if transcript was edited
            if transcriptWasEdited && sessionSummary != nil {
                regenerateSummaryPrompt
            }
        }
    }
    
    private var regenerateSummaryPrompt: some View {
        HStack {
            Spacer()
            VStack(spacing: 16) {
                HStack {
                    Image(systemName: "arrow.triangle.2.circlepath")
                        .foregroundStyle(AppTheme.magenta)
                    Text("Transcript was edited")
                        .font(.subheadline)
                        .fontWeight(.medium)
                }
                
                Text("The summary may be outdated. Would you like to regenerate it?")
                    .font(.caption)
                    .foregroundStyle(.secondary)
                    .multilineTextAlignment(.center)
                
                HStack(spacing: 12) {
                    // Dismiss button
                    Button {
                        transcriptWasEdited = false
                    } label: {
                        Text("Not Now")
                            .font(.subheadline)
                            .fontWeight(.medium)
                    }
                    .buttonStyle(.bordered)
                    .tint(.secondary)
                    
                    // Regenerate button with loading state
                    Button {
                        Task {
                            await regenerateSummary()
                            transcriptWasEdited = false
                        }
                    } label: {
                        HStack {
                            if isRegeneratingSummary {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                    .scaleEffect(0.8)
                            } else {
                                Image(systemName: "sparkles")
                            }
                            Text(isRegeneratingSummary ? "Regenerating..." : "Regenerate Summary")
                        }
                        .font(.subheadline)
                        .fontWeight(.medium)
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(AppTheme.magenta)
                    .disabled(isRegeneratingSummary)
                }
            }
            .padding()
            .background(
                RadialGradient(
                    colors: [AppTheme.magenta.opacity(0.15), AppTheme.magenta.opacity(0.05)],
                    center: .center,
                    startRadius: 0,
                    endRadius: 100
                )
            )
            .cornerRadius(12)
            .frame(maxWidth: 400)
            Spacer()
        }
    }
    
    private func saveTranscriptEdit(segmentId: UUID, newText: String) {
        Task {
            do {
                try await coordinator.updateTranscriptText(segmentId: segmentId, newText: newText)
                transcriptWasEdited = true
                await loadTranscription()  // Refresh the segments
                coordinator.showSuccess("Transcript updated")
            } catch {
                print("‚ùå [SessionDetailView] Failed to save transcript edit: \(error)")
                coordinator.showError("Failed to save edit")
            }
        }
    }
    
    private func seekToChunk(_ chunkIndex: Int) {
        var targetTime: TimeInterval = 0
        for i in 0..<chunkIndex {
            targetTime += session.chunks[i].duration
        }
        seekToTotalTime(targetTime)
    }
    
    private func startPlaybackUpdateTimer() {
        stopPlaybackUpdateTimer()
        // Update at 30fps for smooth visual feedback (matches waveform animation)
        playbackUpdateTimer = Timer.scheduledTimer(withTimeInterval: 1/30, repeats: true) { _ in
            Task { @MainActor in
                self.forceUpdateTrigger.toggle()
            }
        }
        // Add timer to common run loop mode to ensure it fires during UI interactions
        if let timer = playbackUpdateTimer {
            RunLoop.main.add(timer, forMode: .common)
        }
    }
    
    private func stopPlaybackUpdateTimer() {
        playbackUpdateTimer?.invalidate()
        playbackUpdateTimer = nil
    }
    
    private func startTranscriptionCheckTimer() {
        // Check immediately
        checkTranscriptionStatus()
        
        // Then check every 2 seconds
        transcriptionCheckTimer = Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { _ in
            Task { @MainActor in
                self.checkTranscriptionStatus()
            }
        }
    }
    
    private func stopTranscriptionCheckTimer() {
        transcriptionCheckTimer?.invalidate()
        transcriptionCheckTimer = nil
    }
    
    private func checkTranscriptionStatus() {
        // Check using real-time status tracking from coordinator
        let chunkIds = Set(session.chunks.map { $0.id })
        
        // Check if any chunks are actively being transcribed right now
        let hasTranscribing = !chunkIds.isDisjoint(with: coordinator.transcribingChunkIds)
        
        // For chunks not actively transcribing, check if they have transcript segments
        // This handles both new transcriptions and previously completed ones
        let chunksWithTranscripts = Set(transcriptSegments.map { $0.audioChunkID })
        
        // A session is complete if:
        // 1. No chunks are currently being transcribed AND
        // 2. All chunks either have transcripts OR are marked as failed
        let allChunksAccountedFor = chunkIds.allSatisfy { chunkId in
            chunksWithTranscripts.contains(chunkId) || 
            coordinator.failedChunkIds.contains(chunkId)
        }
        
        let wasComplete = isTranscriptionComplete
        isTranscriptionComplete = !hasTranscribing && allChunksAccountedFor
        
        // If just completed, reload data and stop checking
        if !wasComplete && isTranscriptionComplete {
            Task {
                stopTranscriptionCheckTimer()
                // Reload transcription to get the latest segments
                await loadTranscription()
                // Load session summary
                await loadSessionSummary()
            }
        }
    }
    
    private var groupedByChunk: [(chunkIndex: Int, text: String)] {
        // Group segments by chunk and combine text
        var groups: [Int: [TranscriptSegment]] = [:]
        
        for segment in transcriptSegments {
            for (index, chunk) in session.chunks.enumerated() {
                if segment.audioChunkID == chunk.id {
                    groups[index, default: []].append(segment)
                    break
                }
            }
        }
        
        return groups.keys.sorted().map { chunkIndex in
            let segments = groups[chunkIndex] ?? []
            let text = segments.map { $0.text }.joined(separator: " ")
            return (chunkIndex, text)
        }
    }
    
    private var groupedSegmentsByChunk: [(chunkIndex: Int, segments: [TranscriptSegment])] {
        // Group segments by chunk, preserving segment objects for editing
        var groups: [Int: [TranscriptSegment]] = [:]
        
        for segment in transcriptSegments {
            for (index, chunk) in session.chunks.enumerated() {
                if segment.audioChunkID == chunk.id {
                    groups[index, default: []].append(segment)
                    break
                }
            }
        }
        
        return groups.keys.sorted().map { chunkIndex in
            (chunkIndex, groups[chunkIndex] ?? [])
        }
    }
    
    // Combined transcript text for sharing
    private var transcriptText: String {
        groupedByChunk.map { $0.text }.joined(separator: "\n\n")
    }
    
    // MARK: - Session Title Section
    
    private var sessionTitleSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            if isEditingTitle {
                HStack {
                    TextField("Session Title", text: $sessionTitle)
                        .textFieldStyle(.roundedBorder)
                        .font(.title2)
                        .focused($isTextFieldFocused)
                    
                    Button("Save") {
                        isEditingTitle = false
                        saveTitle()
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(AppTheme.purple)
                    
                    Button("Cancel") {
                        isEditingTitle = false
                        sessionTitle = session.title ?? ""
                    }
                    .buttonStyle(.bordered)
                    .tint(AppTheme.skyBlue)
                }
            } else {
                HStack {
                    VStack(alignment: .leading, spacing: 4) {
                        if !sessionTitle.isEmpty {
                            Text(sessionTitle)
                                .font(.title2)
                                .fontWeight(.semibold)
                        }
                        
                        Text(session.startTime.formatted(date: .abbreviated, time: .shortened))
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                    }
                    
                    Spacer()
                    
                    Button {
                        isEditingTitle = true
                        isTextFieldFocused = true
                    } label: {
                        Image(systemName: "pencil.circle")
                            .font(.title2)
                            .foregroundStyle(AppTheme.skyBlue)
                    }
                }
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .cornerRadius(12)
    }
    
    // MARK: - Session Summary Section
    
    private var sessionSummaryPlaceholderSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text("Recording Chunks")
                    .font(.headline)
                
                Spacer()
                
                // Generate button
                Button {
                    Task {
                        await regenerateSummary()
                    }
                } label: {
                    HStack(spacing: 4) {
                        if isRegeneratingSummary {
                            ProgressView()
                                .tint(AppTheme.purple)
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: "sparkles")
                                .font(.body)
                        }
                        Text("Generate")
                            .font(.subheadline)
                            .fontWeight(.medium)
                    }
                    .foregroundStyle(
                        LinearGradient(
                            colors: [AppTheme.darkPurple, AppTheme.magenta],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .padding(.horizontal, 14)
                    .padding(.vertical, 10)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(AppTheme.purple.opacity(0.1))
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .stroke(
                                LinearGradient(
                                    colors: [AppTheme.purple.opacity(0.4), AppTheme.magenta.opacity(0.3)],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                ),
                                lineWidth: 1.5
                            )
                    )
                    .contentShape(Rectangle())
                }
                .buttonStyle(.plain)
                .disabled(isRegeneratingSummary)
            }
            
            if isRegeneratingSummary {
                HStack {
                    ProgressView()
                        .tint(AppTheme.purple)
                    Text("Generating AI summary...")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                }
                .padding(.top, 8)
            } else {
                Text("Summary not yet generated. Tap Generate to create an AI summary of this recording.")
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
                    .italic()
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .fill(AppTheme.cardGradient(for: colorScheme))
                .allowsHitTesting(false)
        )
        .cornerRadius(12)
    }
    
    private func sessionSummaryErrorSection(error: String) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text("Recording Summary")
                    .font(.headline)
                
                Spacer()
                
                // Retry button
                Button {
                    Task {
                        await regenerateSummary()
                    }
                } label: {
                    HStack(spacing: 4) {
                        if isRegeneratingSummary {
                            ProgressView()
                                .tint(.orange)
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: "arrow.clockwise")
                                .font(.body)
                        }
                        Text("Retry")
                            .font(.subheadline)
                            .fontWeight(.medium)
                    }
                    .foregroundStyle(.orange)
                    .padding(.horizontal, 14)
                    .padding(.vertical, 10)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(Color.orange.opacity(0.1))
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .stroke(
                                Color.orange.opacity(0.4),
                                lineWidth: 1.5
                            )
                    )
                    .contentShape(Rectangle())
                }
                .buttonStyle(.plain)
                .disabled(isRegeneratingSummary)
            }
            
            VStack(alignment: .leading, spacing: 8) {
                HStack(spacing: 8) {
                    Image(systemName: "exclamationmark.triangle.fill")
                        .foregroundStyle(.orange)
                    Text("Summary Generation Failed")
                        .font(.subheadline)
                        .fontWeight(.medium)
                }
                
                Text(error)
                    .font(.caption)
                    .foregroundStyle(.secondary)
                
                if error.contains("API key") {
                    Text("Go to Settings ‚Üí AI & Intelligence to add your API key.")
                        .font(.caption)
                        .foregroundStyle(.blue)
                }
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .fill(AppTheme.cardGradient(for: colorScheme))
                .allowsHitTesting(false)
        )
        .cornerRadius(12)
    }
    
    private func sessionSummarySection(summary: Summary) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text("Recording Summary")
                    .font(.headline)
                
                Spacer()
                
                // Copy button
                Button {
                    UIPasteboard.general.string = summary.text
                    coordinator.showSuccess("Summary copied to clipboard")
                } label: {
                    Image(systemName: "doc.on.doc")
                        .font(.body)
                        .foregroundStyle(AppTheme.skyBlue)
                        .padding(10)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(AppTheme.skyBlue.opacity(0.1))
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: 8)
                                .stroke(
                                    LinearGradient(
                                        colors: [AppTheme.skyBlue.opacity(0.4), AppTheme.purple.opacity(0.3)],
                                        startPoint: .leading,
                                        endPoint: .trailing
                                    ),
                                    lineWidth: 1.5
                                )
                        )
                        .contentShape(Rectangle())
                }
                .buttonStyle(.plain)
                
                // Regenerate button
                Button {
                    Task {
                        // If notes were appended, ask user what to do
                        if notesWereAppended {
                            showRegenerateWithNotesAlert = true
                        } else {
                            await regenerateSummary()
                        }
                    }
                } label: {
                    HStack(spacing: 4) {
                        if isRegeneratingSummary {
                            ProgressView()
                                .tint(AppTheme.purple)
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: "sparkles")
                                .font(.body)
                        }
                    }
                    .foregroundStyle(
                        LinearGradient(
                            colors: [AppTheme.darkPurple, AppTheme.magenta],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .padding(10)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(AppTheme.purple.opacity(0.1))
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .stroke(
                                LinearGradient(
                                    colors: [AppTheme.purple.opacity(0.4), AppTheme.magenta.opacity(0.3)],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                ),
                                lineWidth: 1.5
                            )
                    )
                    .contentShape(Rectangle())
                }
                .buttonStyle(.plain)
                .disabled(isRegeneratingSummary)
            }
            
            Text(summary.text)
                .font(.body)
                .foregroundStyle(.primary)
            
            // Show engine tier if available
            if let engineTier = summary.engineTier {
                HStack {
                    Image(systemName: engineIcon(for: engineTier))
                        .font(.caption)
                    Text("Generated by \(engineDisplayName(for: engineTier))")
                        .font(.caption)
                }
                .foregroundStyle(.secondary)
                .padding(.top, 4)
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .fill(AppTheme.cardGradient(for: colorScheme))
                .allowsHitTesting(false)
        )
        .cornerRadius(12)
    }
    
    // MARK: - Additional Notes Section
    
    private var personalNotesSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text("Additional Notes")
                    .font(.headline)
                
                Spacer()
                
                if isEditingNotes {
                    Button("Done") {
                        isEditingNotes = false
                        saveNotes()
                    }
                    .buttonStyle(.borderedProminent)
                } else {
                    Button {
                        isEditingNotes = true
                    } label: {
                        Image(systemName: "pencil.circle")
                            .font(.body)
                            .foregroundStyle(AppTheme.skyBlue)
                            .padding(10)
                            .background(
                                RoundedRectangle(cornerRadius: 8)
                                    .fill(AppTheme.skyBlue.opacity(0.1))
                            )
                            .overlay(
                                RoundedRectangle(cornerRadius: 8)
                                    .stroke(
                                        LinearGradient(
                                            colors: [AppTheme.skyBlue.opacity(0.4), AppTheme.skyBlue.opacity(0.3)],
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        ),
                                        lineWidth: 1.5
                                    )
                            )
                            .contentShape(Rectangle())
                    }
                    .buttonStyle(.plain)
                }
            }
            
            if isEditingNotes {
                TextEditor(text: $sessionNotes)
                    .frame(minHeight: 100)
                    .padding(8)
                    .background(Color(.tertiarySystemBackground))
                    .cornerRadius(8)
            } else if sessionNotes.isEmpty {
                Text("Tap the pencil to add additional notes...")
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
                    .italic()
            } else {
                Text(sessionNotes)
                    .font(.body)
                    .foregroundStyle(.primary)
            }
            
            // Subtle button to append notes to summary
            if shouldShowRegenerateWithNotesButton {
                Button {
                    Task {
                        await regenerateSummaryWithNotes()
                    }
                } label: {
                    HStack(spacing: 6) {
                        Image(systemName: "plus.circle")
                            .font(.caption)
                        Text("Append to Summary")
                            .font(.caption)
                            .fontWeight(.medium)
                    }
                    .foregroundStyle(AppTheme.purple)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 6)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(AppTheme.purple.opacity(0.1))
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .stroke(AppTheme.purple.opacity(0.3), lineWidth: 1)
                    )
                }
                .buttonStyle(.plain)
                .padding(.top, 4)
            }
        }
        .padding()
        .background(Color(.secondarySystemBackground))
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .fill(AppTheme.cardGradient(for: colorScheme))
                .allowsHitTesting(false)
        )
        .cornerRadius(12)
    }
    
    /// Show regenerate button only if: notes exist, summary exists, and notes changed after summary
    private var shouldShowRegenerateWithNotesButton: Bool {
        !sessionNotes.isEmpty &&
        sessionSummary != nil &&
        sessionNotes != initialSessionNotes
    }
    
    // MARK: - Helper Methods
    
    private func engineIcon(for tier: String) -> String {
        switch tier.lowercased() {
        case "apple": return "apple.intelligence"
        case "basic": return "bolt.fill"
        case "external": return "sparkles"
        case "rollup": return "arrow.triangle.merge"
        case "year wrap": return "sparkles"
        default: return "cpu"
        }
    }
    
    private func engineDisplayName(for tier: String) -> String {
        switch tier.lowercased() {
        case "apple": return "Apple Intelligence"
        case "basic": return "Basic"
        case "external": return "Year Wrapped Pro AI"
        case "rollup": return "Rollup"
        case "year wrap": return "Year Wrap"
        default: return tier.capitalized
        }
    }
    
    private func loadSessionMetadata() async {
        do {
            // Load metadata and track initial notes value
            let metadata = try await coordinator.fetchSessionMetadata(sessionId: session.sessionId)
            await MainActor.run {
                sessionTitle = metadata?.title ?? ""
                sessionNotes = metadata?.notes ?? ""
                initialSessionNotes = metadata?.notes ?? ""  // Track initial state
                isFavorite = metadata?.isFavorite ?? false
            }
        } catch {
            print("‚ùå [SessionDetailView] Failed to load metadata: \(error)")
        }
    }
    
    private func saveNotes() {
        Task {
            do {
                try await coordinator.updateSessionNotes(
                    sessionId: session.sessionId,
                    notes: sessionNotes.isEmpty ? nil : sessionNotes
                )
            } catch {
                print("‚ùå [SessionDetailView] Failed to save notes: \(error)")
            }
        }
    }
    
    private func regenerateSummaryWithNotes() async {
        guard !sessionNotes.isEmpty else { return }
        
        print("üìù [SessionDetailView] Appending notes to existing summary...")
        
        do {
            // Call coordinator to append notes
            try await coordinator.appendNotesToSessionSummary(sessionId: session.sessionId, notes: sessionNotes)
            
            print("‚úÖ [SessionDetailView] Successfully appended notes to summary")
            
            // Reload summary to show changes
            await loadSessionSummary()
            
            // Mark that notes were incorporated and appended
            initialSessionNotes = sessionNotes
            notesWereAppended = true
            
            coordinator.showSuccess("Notes appended to summary")
        } catch {
            print("‚ùå [SessionDetailView] Failed to append notes to summary: \(error)")
            summaryLoadError = error.localizedDescription
            coordinator.showError("Failed to append notes")
        }
    }
    
    private func saveTitle() {
        Task {
            do {
                let titleToSave = sessionTitle.isEmpty ? nil : sessionTitle
                try await coordinator.updateSessionTitle(sessionId: session.sessionId, title: titleToSave)
                coordinator.showSuccess("Title saved")
            } catch {
                print("‚ùå [SessionDetailView] Failed to save title: \(error)")
            }
        }
    }
    
    private func regenerateSummary(reappendNotes: Bool = false) async {
        isRegeneratingSummary = true
        summaryLoadError = nil
        
        // Get active engine to customize overlay message
        guard let summCoord = coordinator.summarizationCoordinator else { return }
        let activeEngine = await summCoord.getActiveEngine()
        activeEngineForGeneration = activeEngine
        
        // Show overlay for all engines with different messages
        showGenerationOverlay = true
        generationProgress = 0.0
        
        // Set initial phase based on engine
        switch activeEngine {
        case .basic:
            generationPhase = "Processing transcript..."
        case .local:
            generationPhase = "Running local AI model..."
        case .apple:
            generationPhase = "Preparing..."
        case .external:
            generationPhase = "Connecting to AI service..."
        }
        
        defer { 
            isRegeneratingSummary = false
            showGenerationOverlay = false
        }
        
        do {
            // Force regeneration if transcript was edited, otherwise check cache
            let forceRegenerate = transcriptWasEdited
            
            // Start progress simulation with engine-specific phases
            Task {
                try? await Task.sleep(nanoseconds: 2_000_000_000) // 2s
                if !Task.isCancelled && showGenerationOverlay {
                    generationProgress = 0.1
                    switch activeEngine {
                    case .basic:
                        generationPhase = "Extracting key information..."
                    case .local:
                        generationPhase = "Loading local AI model..."
                    case .apple:
                        generationPhase = "Loading on-device AI model..."
                    case .external:
                        generationPhase = "Uploading transcript securely..."
                    }
                }
                
                try? await Task.sleep(nanoseconds: 2_500_000_000) // 2.5s
                if !Task.isCancelled && showGenerationOverlay {
                    generationProgress = 0.3
                    switch activeEngine {
                    case .basic:
                        generationPhase = "Analyzing content..."
                    case .local:
                        generationPhase = "Running inference..."
                    case .apple:
                        generationPhase = "Analyzing transcript..."
                    case .external:
                        generationPhase = "AI analyzing your transcript..."
                    }
                }
                
                try? await Task.sleep(nanoseconds: 2_500_000_000) // 2.5s
                if !Task.isCancelled && showGenerationOverlay {
                    generationProgress = 0.5
                    switch activeEngine {
                    case .basic:
                        generationPhase = "Identifying main topics..."
                    case .local:
                        generationPhase = "Processing with Phi-3.5..."
                    case .apple:
                        generationPhase = "Processing key points..."
                    case .external:
                        generationPhase = "Generating intelligent insights..."
                    }
                }
                
                try? await Task.sleep(nanoseconds: 2_500_000_000) // 2.5s
                if !Task.isCancelled && showGenerationOverlay {
                    generationProgress = 0.7
                    switch activeEngine {
                    case .basic:
                        generationPhase = "Creating summary..."
                    case .local:
                        generationPhase = "Generating local summary..."
                    case .apple:
                        generationPhase = "Generating summary..."
                    case .external:
                        generationPhase = "Crafting comprehensive summary..."
                    }
                }
                
                try? await Task.sleep(nanoseconds: 2_500_000_000) // 2.5s
                if !Task.isCancelled && showGenerationOverlay {
                    generationProgress = 0.9
                    generationPhase = "Finalizing..."
                }
            }
            
            // Actual generation (notes are never passed to AI anymore)
            try await coordinator.generateSessionSummary(
                sessionId: session.sessionId, 
                forceRegenerate: true,
                includeNotes: false
            )
            
            // If requested, re-append notes after regeneration
            if reappendNotes && !sessionNotes.isEmpty {
                try? await coordinator.appendNotesToSessionSummary(sessionId: session.sessionId, notes: sessionNotes)
                notesWereAppended = true
            } else {
                notesWereAppended = false
            }
            
            generationProgress = 1.0
            generationPhase = "Complete!"
            
            await loadSessionSummary()
            // Reset edit tracking after summary is regenerated
            editedChunkIds.removeAll()
            transcriptWasEdited = false
            
            try? await Task.sleep(nanoseconds: 500_000_000) // Show complete state briefly
            
            // Show success with engine used
            if let summary = sessionSummary {
                let engineName = summary.engineTier ?? "AI"
                coordinator.showSuccess("Summary generated with \(engineName)")
            } else {
                coordinator.showSuccess("Summary generated")
            }
        } catch {
            print("‚ùå [SessionDetailView] Failed to regenerate summary: \(error)")
            summaryLoadError = error.localizedDescription
            
            // Better error messaging
            if error.localizedDescription.contains("internet") || error.localizedDescription.contains("network") {
                coordinator.showError("Network error. Using offline summary.")
            } else if error.localizedDescription.contains("API key") {
                coordinator.showError("API key required for external AI")
            } else {
                coordinator.showError("Failed to generate summary")
            }
        }
    }

    private var isPlayingThisSession: Bool {
        // Check if any chunk from this session is currently playing
        guard let currentURL = coordinator.audioPlayback.currentlyPlayingURL else { return false }
        return session.chunks.contains { $0.fileURL == currentURL }
    }
    
    private var currentChunkIndex: Int? {
        // Get the index of the currently playing chunk
        guard let currentURL = coordinator.audioPlayback.currentlyPlayingURL else { return nil }
        return session.chunks.firstIndex { $0.fileURL == currentURL }
    }
    
    // Generate consistent waveform heights (seeded for consistency)
    private func waveformHeight(for index: Int) -> CGFloat {
        let seed = Double(index) * 0.12345
        let height = sin(seed) * sin(seed * 2.3) * sin(seed * 1.7)
        return 20 + abs(height) * 40
    }
    
    // Calculate total elapsed time across all chunks
    private var totalElapsedTime: TimeInterval {
        // Use forceUpdateTrigger to ensure UI updates
        _ = forceUpdateTrigger
        
        guard isPlayingThisSession,
              let currentURL = coordinator.audioPlayback.currentlyPlayingURL,
              let currentChunkIndex = session.chunks.firstIndex(where: { $0.fileURL == currentURL }) else {
            return 0
        }
        
        // Sum durations of all previous chunks
        var elapsed: TimeInterval = 0
        for i in 0..<currentChunkIndex {
            elapsed += session.chunks[i].duration
        }
        
        // Add current chunk's progress
        elapsed += coordinator.audioPlayback.currentTime
        
        return elapsed
    }
    
    // Calculate playback progress as percentage (0.0 to 1.0)
    private var playbackProgress: Double {
        // Use forceUpdateTrigger to ensure UI updates
        _ = forceUpdateTrigger
        
        guard session.totalDuration > 0 else { return 0 }
        
        if isPlayingThisSession {
            return totalElapsedTime / session.totalDuration
        } else {
            return 0
        }
    }
    
    // Seek to a specific time in the total session
    private func seekToTotalTime(_ targetTime: TimeInterval) {
        var remainingTime = targetTime
        
        // Find which chunk contains this time
        for (index, chunk) in session.chunks.enumerated() {
            if remainingTime <= chunk.duration {
                // Check if we're already in this chunk
                if let currentURL = coordinator.audioPlayback.currentlyPlayingURL,
                   session.chunks[index].fileURL == currentURL {
                    // Same chunk - just seek within it
                    coordinator.audioPlayback.seek(to: remainingTime)
                } else {
                    // Different chunk - restart playback from this chunk
                    let chunkURLs = session.chunks.map { $0.fileURL }
                    let wasPlaying = coordinator.audioPlayback.isPlaying
                    
                    Task {
                        try await coordinator.audioPlayback.playSequence(urls: Array(chunkURLs.dropFirst(index))) {
                            print("‚úÖ [SessionDetailView] Session playback completed after seek")
                        }
                        
                        // Seek within this chunk immediately for smooth scrubbing
                        // Minimal delay to ensure player is initialized
                        try? await Task.sleep(for: .milliseconds(10))
                        coordinator.audioPlayback.seek(to: remainingTime)
                        
                        // If wasn't playing before, pause immediately after seeking
                        if !wasPlaying {
                            coordinator.audioPlayback.pause()
                        }
                    }
                }
                
                return
            }
            
            remainingTime -= chunk.duration
        }
    }
    
    // MARK: - AI Generation Overlay
    
    private var aiGenerationOverlay: some View {
        ZStack {
            // Adaptive blurred background
            Color.black.opacity(0.7)
                .ignoresSafeArea()
                .blur(radius: 2)
            
            VStack(spacing: 24) {
                // CPU icon with animation
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [AppTheme.purple.opacity(0.3), AppTheme.magenta.opacity(0.2)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 100, height: 100)
                        .scaleEffect(1.0 + generationProgress * 0.2)
                        .animation(.easeInOut(duration: 1.0).repeatForever(autoreverses: true), value: generationProgress)
                    
                    Image(systemName: "cpu")
                        .font(.system(size: 50))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [AppTheme.purple, AppTheme.magenta],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                }
                
                VStack(spacing: 12) {
                    Text(activeEngineForGeneration == .basic ? "Processing" : "AI Processing")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundStyle(.primary)
                    
                    // Progress bar
                    ZStack(alignment: .leading) {
                        RoundedRectangle(cornerRadius: 10)
                            .fill(Color.secondary.opacity(0.3))
                            .frame(width: 280, height: 8)
                        
                        RoundedRectangle(cornerRadius: 10)
                            .fill(
                                LinearGradient(
                                    colors: [AppTheme.purple, AppTheme.magenta],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .frame(width: 280 * generationProgress, height: 8)
                            .animation(.linear(duration: 0.3), value: generationProgress)
                    }
                    
                    // Percentage
                    Text("\(Int(generationProgress * 100))%")
                        .font(.title3)
                        .fontWeight(.semibold)
                        .foregroundStyle(.primary)
                        .monospacedDigit()
                    
                    // Current phase
                    Text(generationPhase)
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                        .multilineTextAlignment(.center)
                        .frame(minHeight: 44)
                        .padding(.horizontal, 20)
                }
                
                // Info box with engine-specific message
                if let engineTier = activeEngineForGeneration {
                    VStack(alignment: .leading, spacing: 12) {
                        HStack(spacing: 8) {
                            Image(systemName: "info.circle.fill")
                                .foregroundStyle(AppTheme.skyBlue)
                            Text(engineTier == .basic ? "What's happening?" : "Why does this take time?")
                                .font(.subheadline)
                                .fontWeight(.semibold)
                                .foregroundStyle(.primary)
                        }
                        
                        // Engine-specific description
                        Group {
                            switch engineTier {
                            case .basic:
                                Text("Life Wrapped is creating a basic summary by extracting key information from your transcript. This is a simple, fast process that works offline.")
                            case .local:
                                Text("Life Wrapped is using Phi-3.5, a powerful local AI model running directly on your device. This provides high-quality summaries while keeping all your data private.")
                            case .apple:
                                Text("Life Wrapped performs a comprehensive analysis directly on your iPhone using Apple Intelligence. No data leaves your device ‚Äî it's completely private.")
                            case .external:
                                let provider = UserDefaults.standard.string(forKey: "externalAPIProvider") ?? "OpenAI"
                                Text("Life Wrapped uses \(provider)'s advanced AI to perform intelligent processing and generate the best possible summary of your transcript. This provides the most comprehensive and insightful analysis.")
                            }
                        }
                        .font(.caption)
                        .foregroundStyle(.secondary)
                        .fixedSize(horizontal: false, vertical: true)
                        
                        HStack(spacing: 8) {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundStyle(.green)
                            Text("Once complete, future views of this session are instant!")
                                .font(.caption)
                                .fontWeight(.medium)
                                .foregroundStyle(.primary)
                        }
                    }
                    .padding(16)
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(Color.secondary.opacity(0.1))
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(Color.secondary.opacity(0.3), lineWidth: 1)
                    )
                    .padding(.horizontal, 20)
                }
            }
            .padding(32)
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .fill(Color(.systemBackground).opacity(0.95))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 20)
                    .stroke(
                        LinearGradient(
                            colors: [AppTheme.purple.opacity(0.5), AppTheme.magenta.opacity(0.5)],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 2
                    )
            )
            .shadow(color: .black.opacity(0.3), radius: 20, x: 0, y: 10)
            .padding(.horizontal, 40)
        }
    }
    
    private func loadSessionSummary() async {
        summaryLoadError = nil
        do {
            sessionSummary = try await coordinator.fetchSessionSummary(sessionId: session.sessionId)
            if sessionSummary != nil {
                print("‚ú® [SessionDetailView] Loaded session summary")
            } else {
                print("‚ÑπÔ∏è [SessionDetailView] No session summary found (not yet generated)")
                summaryLoadError = "Summary not yet generated. Transcription must complete first."
            }
        } catch {
            print("‚ùå [SessionDetailView] Failed to load session summary: \(error)")
            summaryLoadError = error.localizedDescription
        }
    }
    
    private func loadTranscription() async {
        print("üìÑ [SessionDetailView] Loading transcription for session \(session.sessionId)")
        isLoading = true
        loadError = nil
        
        do {
            transcriptSegments = try await coordinator.fetchSessionTranscript(sessionId: session.sessionId)
            print("üìÑ [SessionDetailView] Loaded \(transcriptSegments.count) transcript segments")
            
            // Debug: Log which chunks have transcripts
            let chunksWithTranscripts = Set(transcriptSegments.map { $0.audioChunkID })
            for chunk in session.chunks {
                let hasTranscript = chunksWithTranscripts.contains(chunk.id)
                let isTranscribing = coordinator.transcribingChunkIds.contains(chunk.id)
                let isFailed = coordinator.failedChunkIds.contains(chunk.id)
                print("üìÑ [SessionDetailView] Chunk \(chunk.chunkIndex): hasTranscript=\(hasTranscript), transcribing=\(isTranscribing), failed=\(isFailed)")
            }
        } catch {
            print("‚ùå [SessionDetailView] Failed to load transcription: \(error)")
            loadError = error.localizedDescription
        }
        
        isLoading = false
    }
    
    private func refreshSession() async {
        print("üîÑ [SessionDetailView] Manually refreshing session...")
        
        // Reload transcription
        await loadTranscription()
        
        // Force transcription status check
        checkTranscriptionStatus()
        
        // Check if any chunks need to be queued for transcription
        let chunksWithTranscripts = Set(transcriptSegments.map { $0.audioChunkID })
        
        print("üìä [SessionDetailView] Chunk analysis:")
        print("   - Total chunks in session: \(session.chunks.count)")
        print("   - Chunks with transcripts: \(chunksWithTranscripts.count)")
        print("   - Currently transcribing: \(coordinator.transcribingChunkIds.count)")
        print("   - Failed: \(coordinator.failedChunkIds.count)")
        
        for chunk in session.chunks {
            let hasTranscript = chunksWithTranscripts.contains(chunk.id)
            let isTranscribing = coordinator.transcribingChunkIds.contains(chunk.id)
            let isFailed = coordinator.failedChunkIds.contains(chunk.id)
            let isTranscribed = coordinator.transcribedChunkIds.contains(chunk.id)
            
            print("   - Chunk \(chunk.chunkIndex): transcript=\(hasTranscript), transcribing=\(isTranscribing), transcribed=\(isTranscribed), failed=\(isFailed)")
            
            if !hasTranscript && !isTranscribing && !isFailed {
                print("üö® [SessionDetailView] Chunk \(chunk.chunkIndex) is ORPHANED - forcing into transcription queue")
                // Force this chunk into transcription by calling retry
                // This will add it to pendingTranscriptionIds and start processing
                await coordinator.retryTranscription(chunkId: chunk.id)
            }
        }
        
        // Wait a bit and reload again
        try? await Task.sleep(for: .seconds(1))
        await loadTranscription()
        checkTranscriptionStatus()
    }
    
    private func playSession() {
        // Trigger haptic feedback
        coordinator.triggerHaptic(.medium)
        
        if isPlayingThisSession {
            // Pause if playing
            if coordinator.audioPlayback.isPlaying {
                coordinator.audioPlayback.pause()
            } else {
                coordinator.audioPlayback.resume()
            }
        } else {
            // Start sequential playback of all chunks
            let chunkURLs = session.chunks.map { $0.fileURL }
            print("üéµ [SessionDetailView] Starting playback of \(chunkURLs.count) chunks")
            
            // If user has scrubbed before playing, seek to that position
            if scrubbedTime > 0 {
                Task {
                    try await coordinator.audioPlayback.playSequence(urls: chunkURLs) {
                        print("‚úÖ [SessionDetailView] Session playback completed")
                    }
                    // Seek to scrubbed position after playback starts
                    try? await Task.sleep(for: .milliseconds(50))
                    seekToTotalTime(scrubbedTime)
                }
            } else {
                Task {
                    try await coordinator.audioPlayback.playSequence(urls: chunkURLs) {
                        print("‚úÖ [SessionDetailView] Session playback completed")
                    }
                }
            }
        }
    }
    
    private func formatTime(_ time: TimeInterval) -> String {
        let minutes = Int(time) / 60
        let seconds = Int(time) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let hours = Int(duration) / 3600
        let minutes = (Int(duration) % 3600) / 60
        let seconds = Int(duration) % 60
        
        if hours > 0 {
            return String(format: "%d:%02d:%02d", hours, minutes, seconds)
        } else if minutes > 0 {
            return String(format: "%d:%02d", minutes, seconds)
        } else {
            return "\(seconds)s"
        }
    }
}

// MARK: - Language Settings View

struct LanguageSettingsView: View {
    @State private var enabledLanguages: Set<String> = []
    @State private var allLanguages: [String] = []
    @EnvironmentObject var coordinator: AppCoordinator
    
    private let enabledLanguagesKey = "enabledLanguages"
    
    var body: some View {
        List {
            Section {
                Text("Select which languages Life Wrapped should detect in your recordings. All processing happens on-device.")
                    .font(.callout)
                    .foregroundStyle(.secondary)
            }
            
            Section("Supported Languages (\(allLanguages.count))") {
                ForEach(allLanguages, id: \.self) { languageCode in
                    Toggle(isOn: Binding(
                        get: { enabledLanguages.contains(languageCode) },
                        set: { isEnabled in
                            if isEnabled {
                                enabledLanguages.insert(languageCode)
                            } else {
                                enabledLanguages.remove(languageCode)
                            }
                            saveEnabledLanguages()
                        }
                    )) {
                        HStack {
                            Text(LanguageDetector.flagEmoji(for: languageCode))
                                .font(.title3)
                            Text(LanguageDetector.displayName(for: languageCode))
                            Spacer()
                            Text(languageCode)
                                .font(.caption)
                                .foregroundStyle(.secondary)
                                .monospacedDigit()
                        }
                    }
                    .tint(AppTheme.purple)
                }
            }
        }
        .navigationTitle("Languages")
        .navigationBarTitleDisplayMode(.inline)
        .task {
            loadLanguages()
        }
    }
    
    private func loadLanguages() {
        allLanguages = LanguageDetector.supportedLanguages()
        
        if let savedLanguages = UserDefaults.standard.array(forKey: enabledLanguagesKey) as? [String] {
            enabledLanguages = Set(savedLanguages)
        } else {
            // Default to English and Spanish only
            let defaultLanguages = ["en", "es"]
            enabledLanguages = Set(defaultLanguages.filter { allLanguages.contains($0) })
            saveEnabledLanguages()
        }
    }
    
    private func saveEnabledLanguages() {
        UserDefaults.standard.set(Array(enabledLanguages), forKey: enabledLanguagesKey)
        coordinator.showSuccess("Language preferences saved")
    }
}

// MARK: - Overview Summary Card

struct OverviewSummaryCard: View {
    let summary: Summary
    let periodTitle: String
    let sessionCount: Int
    let sessionsInPeriod: [RecordingSession]
    let coordinator: AppCoordinator
    let onRegenerate: (() async -> Void)?
    let wrapAction: (() -> Void)?
    let wrapIsLoading: Bool
    
    @State private var isRegenerating = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header with action buttons
            headerSection
            
            // Summary text - larger, selectable, in its own container
            summaryTextSection
            
            // Topics tags
            if let topicsJSON = summary.topicsJSON {
                TopicTagsView(topicsJSON: topicsJSON)
            }
            
            // Engine tier badge
            if let engineTier = summary.engineTier {
                engineBadge(tier: engineTier)
            }
        }
        .padding(.vertical, 8)
    }
    
    // MARK: - Header Section
    
    private var headerSection: some View {
        HStack(alignment: .top, spacing: 12) {
            VStack(alignment: .leading, spacing: 4) {
                Text("üìù \(periodTitle)")
                    .font(.headline)
                Text("Based on \(sessionCount) session\(sessionCount == 1 ? "" : "s")")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
            
            Spacer()
            
            // Copy button
            Button {
                UIPasteboard.general.string = summary.text
                coordinator.showSuccess("Summary copied")
            } label: {
                Image(systemName: "doc.on.doc")
                    .font(.title3)
                    .foregroundStyle(.blue)
                    .frame(width: 44, height: 44)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(8)
            }
            .buttonStyle(.plain)
            
            // Regenerate button (optional)
            if let onRegenerate {
                Button {
                    Task {
                        isRegenerating = true
                        await onRegenerate()
                        isRegenerating = false
                    }
                } label: {
                    if isRegenerating {
                        ProgressView()
                            .frame(width: 44, height: 44)
                    } else {
                        Image(systemName: "arrow.clockwise")
                            .font(.title3)
                            .foregroundStyle(.orange)
                            .frame(width: 44, height: 44)
                            .background(Color.orange.opacity(0.1))
                            .cornerRadius(8)
                    }
                }
                .buttonStyle(.plain)
                .disabled(isRegenerating)
            }

            if let wrapAction {
                Button {
                    wrapAction()
                } label: {
                    if wrapIsLoading {
                        ProgressView()
                            .frame(width: 44, height: 44)
                    } else {
                        Image(systemName: "sparkles")
                            .font(.title3)
                            .foregroundStyle(.purple)
                            .frame(width: 44, height: 44)
                            .background(Color.purple.opacity(0.1))
                            .cornerRadius(8)
                    }
                }
                .buttonStyle(.plain)
                .disabled(isRegenerating || wrapIsLoading)
                .accessibilityLabel("Generate Year Wrap")
            }
        }
    }
    
    // MARK: - Summary Text Section
    
    private var summaryTextSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            // The summary text in a scrollable, selectable container
            ScrollView {
                Text(summary.text)
                    .font(.body)
                    .foregroundStyle(.primary)
                    .textSelection(.enabled)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            .frame(minHeight: 120, maxHeight: 200)
            .padding(16)
            .background(Color(.tertiarySystemBackground))
            .cornerRadius(12)
        }
    }
    
    // MARK: - Engine Badge
    
    private func engineBadge(tier: String) -> some View {
        HStack(spacing: 6) {
            Image(systemName: engineIcon(for: tier))
                .font(.caption)
            Text("Generated by \(engineDisplayName(for: tier))")
                .font(.caption)
        }
        .foregroundStyle(.secondary)
    }
    
    // MARK: - Helpers
    
    private func engineIcon(for tier: String) -> String {
        switch tier.lowercased() {
        case "apple": return "apple.intelligence"
        case "basic": return "bolt.fill"
        case "external": return "sparkles"
        case "rollup": return "arrow.triangle.merge"
        case "year wrap": return "sparkles"
        default: return "cpu"
        }
    }
    
    private func engineDisplayName(for tier: String) -> String {
        switch tier.lowercased() {
        case "apple": return "Apple Intelligence"
        case "basic": return "Basic"
        case "external": return "Year Wrapped Pro AI"
        case "rollup": return "Rollup"
        case "year wrap": return "Year Wrap"
        default: return tier.capitalized
        }
    }
}

// MARK: - Insight Session Row

struct InsightSessionRow: View {
    @Environment(\.colorScheme) var colorScheme
    let session: RecordingSession
    
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text(session.startTime, style: .time)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundStyle(.primary)
                Text("\(Int(session.totalDuration / 60)) min ‚Ä¢ \(session.chunkCount) part\(session.chunkCount == 1 ? "" : "s")")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
            
            Spacer()
            
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundStyle(.tertiary)
        }
        .padding(.vertical, 10)
        .padding(.horizontal, 16)
        .background(Color(.secondarySystemBackground))
        .overlay(
            RoundedRectangle(cornerRadius: 8)
                .fill(AppTheme.cardGradient(for: colorScheme))
                .allowsHitTesting(false)
        )
        .cornerRadius(8)
    }
}

// MARK: - Session Summary Card (Feed View)

struct SessionSummaryCard: View {
    let summary: Summary
    let coordinator: AppCoordinator
    @Environment(\.colorScheme) var colorScheme
    @State private var isLoadingSession = false
    @State private var showSessionNotFoundAlert = false
    @State private var fetchedSession: RecordingSession?
    @State private var shouldNavigate = false
    
    /// Whether this card is for a session that can be navigated to
    private var isNavigable: Bool {
        summary.sessionId != nil
    }
    
    var body: some View {
        cardContent
            .background(
                Group {
                    if isNavigable {
                        NavigationLink(destination: destinationView, isActive: $shouldNavigate) {
                            EmptyView()
                        }
                        .hidden()
                    }
                }
            )
            .alert("Session Not Found", isPresented: $showSessionNotFoundAlert) {
                Button("OK", role: .cancel) { }
            } message: {
                Text("The recording session for this summary could not be found.")
            }
    }
    
    @ViewBuilder
    private var cardContent: some View {
        if isNavigable {
            Button {
                loadSessionAndNavigate()
            } label: {
                cardBody
            }
            .buttonStyle(.plain)
        } else {
            cardBody
        }
    }
    
    private var cardBody: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Summary text (scrollable with max height)
            ScrollView {
                Text(cleanedSummaryText)
                    .font(.body)
                    .foregroundStyle(.primary)
                    .multilineTextAlignment(.leading)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            .frame(maxHeight: 450)
                
                // Footer with time and copy button
                HStack(spacing: 12) {
                    // Time display (relative + absolute)
                    // Only show relative time for individual sessions, not rollups
                    VStack(alignment: .leading, spacing: 2) {
                        if summary.sessionId != nil {
                            Text(relativeTimeString)
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                        
                        Text(absoluteTimeString)
                            .font(.caption2)
                            .foregroundStyle(.tertiary)
                    }
                    
                    Spacer()
                    
                    // Copy button
                    Button {
                        UIPasteboard.general.string = summary.text
                        coordinator.showSuccess("Summary copied")
                    } label: {
                        Image(systemName: "doc.on.doc")
                            .font(.body)
                            .foregroundStyle(AppTheme.skyBlue)
                            .padding(8)
                            .background(
                                RoundedRectangle(cornerRadius: 6)
                                    .fill(AppTheme.skyBlue.opacity(0.1))
                            )
                            .overlay(
                                RoundedRectangle(cornerRadius: 6)
                                    .stroke(
                                        LinearGradient(
                                            colors: [AppTheme.skyBlue.opacity(0.4), AppTheme.purple.opacity(0.3)],
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        ),
                                        lineWidth: 1.5
                                    )
                            )
                    }
                    .buttonStyle(.plain)
                }
            }
            .padding(12)
            .background(Color(.secondarySystemBackground))
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .fill(AppTheme.cardGradient(for: colorScheme))
                    .allowsHitTesting(false)
            )
            .cornerRadius(12)
            .overlay {
                if isLoadingSession {
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.black.opacity(0.3))
                    ProgressView()
                        .tint(.white)
                }
            }
        }

    @ViewBuilder
    private var destinationView: some View {
        if let session = fetchedSession {
            SessionDetailView(session: session)
        } else {
            EmptyView()
        }
    }
    
    private var relativeTimeString: String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: summary.periodStart, relativeTo: Date())
    }
    
    private var absoluteTimeString: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy 'at' h:mm a"
        return formatter.string(from: summary.periodStart)
    }
    
    // Clean up any stray timestamps from the summary text
    private var cleanedSummaryText: String {
        var text = summary.text
        
        // Remove multiple consecutive timestamps (the main problem)
        let multiTimestampPattern = #"([‚Ä¢‚óè]?\s*[A-Za-z]+\s+\d{1,2},\s+\d{4}\s+\d{1,2}:\d{2}\s+[AP]M:\s*)+"#
        text = text.replacingOccurrences(of: multiTimestampPattern, with: "", options: .regularExpression)
        
        // Remove any remaining single timestamps
        let singleTimestampPattern = #"[‚Ä¢‚óè]?\s*[A-Za-z]+\s+\d{1,2},\s+\d{4}\s+\d{1,2}:\d{2}\s+[AP]M:\s*"#
        while text.range(of: singleTimestampPattern, options: .regularExpression) != nil {
            text = text.replacingOccurrences(of: singleTimestampPattern, with: "", options: .regularExpression)
        }
        
        // Remove any leading bullets or whitespace
        text = text.replacingOccurrences(of: #"^[‚Ä¢‚óè\s]+"#, with: "", options: .regularExpression)
        
        return text.trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    private func loadSessionAndNavigate() {
        guard let sessionId = summary.sessionId else {
            showSessionNotFoundAlert = true
            return
        }
        
        isLoadingSession = true
        
        Task {
            do {
                if let dbManager = await coordinator.getDatabaseManager() {
                    // Fetch chunks for this session
                    let chunks = try await dbManager.fetchChunksBySession(sessionId: sessionId)
                    
                    guard !chunks.isEmpty else {
                        await MainActor.run {
                            showSessionNotFoundAlert = true
                            isLoadingSession = false
                        }
                        return
                    }
                    
                    // Fetch metadata
                    let metadata = try? await dbManager.fetchSessionMetadata(sessionId: sessionId)
                    
                    // Build RecordingSession
                    let session = RecordingSession(
                        sessionId: sessionId,
                        chunks: chunks,
                        title: metadata?.title,
                        notes: metadata?.notes,
                        isFavorite: metadata?.isFavorite ?? false
                    )
                    
                    await MainActor.run {
                        fetchedSession = session
                        shouldNavigate = true
                        isLoadingSession = false
                    }
                } else {
                    await MainActor.run {
                        showSessionNotFoundAlert = true
                        isLoadingSession = false
                    }
                }
            } catch {
                print("‚ùå [SessionSummaryCard] Failed to load session: \(error)")
                await MainActor.run {
                    showSessionNotFoundAlert = true
                    isLoadingSession = false
                }
            }
        }
    }
}

// MARK: - Local Period Summary Card

struct PeriodSummaryCard: View {
    let title: String
    let subtitle: String
    let summary: Summary
    let isRegenerating: Bool
    let onCopy: () -> Void
    let onRegenerate: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Header Row
            HStack(alignment: .top) {
                Text("‚ú®")
                    .font(.title2)
                
                VStack(alignment: .leading, spacing: 4) {
                    Text(title)
                        .font(.title3)
                        .fontWeight(.bold)
                    Text(subtitle)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                
                Spacer()
                
                HStack(spacing: 8) {
                    // Copy
                    Button(action: onCopy) {
                        Image(systemName: "doc.on.doc")
                            .font(.subheadline)
                            .foregroundStyle(AppTheme.skyBlue)
                    }
                    .padding(8)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(AppTheme.skyBlue.opacity(0.1))
                    )
                
                    // Regenerate
                    Button(action: onRegenerate) {
                        if isRegenerating {
                            ProgressView()
                                .tint(AppTheme.purple)
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: "arrow.clockwise")
                                .font(.subheadline)
                                .foregroundStyle(AppTheme.magenta)
                        }
                    }
                    .disabled(isRegenerating)
                    .padding(8)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(AppTheme.magenta.opacity(0.1))
                    )
                }
            }
            
            Divider()
            
            ScrollView {
                Text(summary.text)
                    .font(.body)
                    .foregroundStyle(.primary)
                    .textSelection(.enabled)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(12)
            }
            .frame(minHeight: 150, maxHeight: 250)
            .background(Color(.tertiarySystemBackground))
            .cornerRadius(8)
        }
        .padding(16)
        .background(
            LinearGradient(
                colors: [
                    AppTheme.darkPurple.opacity(0.15),
                    AppTheme.magenta.opacity(0.1),
                    AppTheme.purple.opacity(0.05)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        )
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .stroke(
                    LinearGradient(
                        colors: [AppTheme.magenta.opacity(0.3), AppTheme.purple.opacity(0.2)],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    lineWidth: 2
                )
        )
        .cornerRadius(16)
        .shadow(color: AppTheme.purple.opacity(0.2), radius: 10, x: 0, y: 5)
    }
}

struct GeneratePeriodSummaryCard: View {
    let title: String
    let isGenerating: Bool
    let onGenerate: () -> Void
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        Button(action: onGenerate) {
            VStack(spacing: 16) {
                Image(systemName: "sparkles")
                    .font(.system(size: 48))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [AppTheme.magenta, AppTheme.purple],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                
                VStack(spacing: 8) {
                    Text(title)
                        .font(.title3)
                        .fontWeight(.bold)
                    
                    Text("Generate an on-device summary for this period")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                        .multilineTextAlignment(.center)
                }
                
                if isGenerating {
                    ProgressView()
                        .tint(AppTheme.purple)
                        .scaleEffect(1.1)
                        .padding(.top, 6)
                } else {
                    HStack {
                        Image(systemName: "wand.and.stars")
                        Text("Generate with Local AI")
                            .fontWeight(.semibold)
                    }
                    .foregroundStyle(.white)
                    .padding(.horizontal, 20)
                    .padding(.vertical, 10)
                    .background(
                        LinearGradient(
                            colors: [AppTheme.purple, AppTheme.magenta],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .cornerRadius(10)
                }
            }
            .frame(maxWidth: .infinity)
            .padding(20)
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(AppTheme.cardGradient(for: colorScheme))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .stroke(
                        LinearGradient(
                            colors: [AppTheme.magenta.opacity(0.35), AppTheme.purple.opacity(0.25)],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 1.5
                    )
            )
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Year Wrapped Card

struct YearWrappedCard: View {
    let summary: Summary
    let coordinator: AppCoordinator
    let onRegenerate: () -> Void
    let isRegenerating: Bool
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    HStack(spacing: 8) {
                        Text("‚ú®")
                            .font(.title2)
                        Text("Year Wrapped")
                            .font(.title3)
                            .fontWeight(.bold)
                    }
                    Text("AI-powered yearly summary")
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                
                Spacer()
                
                HStack(spacing: 12) {
                    // Copy button
                    Button {
                        UIPasteboard.general.string = summary.text
                        coordinator.showSuccess("Year Wrapped summary copied")
                    } label: {
                        Image(systemName: "doc.on.doc")
                            .font(.body)
                            .foregroundStyle(AppTheme.skyBlue)
                    }
                    .padding(8)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(AppTheme.skyBlue.opacity(0.1))
                    )
                    
                    // Regenerate button
                    Button {
                        onRegenerate()
                    } label: {
                        if isRegenerating {
                            ProgressView()
                                .tint(AppTheme.purple)
                                .scaleEffect(0.8)
                        } else {
                            Image(systemName: "arrow.clockwise")
                                .font(.body)
                                .foregroundStyle(AppTheme.magenta)
                        }
                    }
                    .disabled(isRegenerating)
                    .padding(8)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(AppTheme.magenta.opacity(0.1))
                    )
                }
            }
            
            Divider()
            
            // Summary text - scrollable
            ScrollView {
                Text(summary.text)
                    .font(.body)
                    .foregroundStyle(.primary)
                    .textSelection(.enabled)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .padding(12)
            }
            .frame(height: 300)
            .background(Color(.tertiarySystemBackground))
            .cornerRadius(8)
        }
        .padding(16)
        .background(
            LinearGradient(
                colors: [
                    AppTheme.darkPurple.opacity(0.15),
                    AppTheme.magenta.opacity(0.1),
                    AppTheme.purple.opacity(0.05)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        )
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .stroke(
                    LinearGradient(
                        colors: [AppTheme.magenta.opacity(0.3), AppTheme.purple.opacity(0.2)],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    lineWidth: 2
                )
        )
        .cornerRadius(16)
        .shadow(color: AppTheme.purple.opacity(0.2), radius: 10, x: 0, y: 5)
    }
}

// MARK: - Generate Year Wrap Card

struct GenerateYearWrapCard: View {
    let onGenerate: () -> Void
    let isGenerating: Bool
    @Environment(\.colorScheme) var colorScheme
    
    var body: some View {
        Button {
            onGenerate()
        } label: {
            VStack(spacing: 16) {
                Image(systemName: "sparkles")
                    .font(.system(size: 48))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [AppTheme.magenta, AppTheme.purple],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                
                VStack(spacing: 8) {
                    Text("Generate Year Wrapped")
                        .font(.title3)
                        .fontWeight(.bold)
                    
                    Text("Create an AI-powered summary of your entire year")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                        .multilineTextAlignment(.center)
                }
                
                if isGenerating {
                    ProgressView()
                        .tint(AppTheme.purple)
                        .scaleEffect(1.2)
                        .padding(.top, 8)
                } else {
                    HStack {
                        Image(systemName: "wand.and.stars")
                        Text("Generate with AI")
                            .fontWeight(.semibold)
                    }
                    .foregroundStyle(.white)
                    .padding(.horizontal, 24)
                    .padding(.vertical, 12)
                    .background(
                        LinearGradient(
                            colors: [AppTheme.magenta, AppTheme.purple],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .cornerRadius(12)
                }
            }
            .frame(maxWidth: .infinity)
            .padding(24)
            .background(
                LinearGradient(
                    colors: [
                        AppTheme.darkPurple.opacity(0.1),
                        AppTheme.magenta.opacity(0.05),
                        AppTheme.purple.opacity(0.05)
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .strokeBorder(
                        style: StrokeStyle(lineWidth: 2, dash: [8, 4])
                    )
                    .foregroundStyle(
                        LinearGradient(
                            colors: [AppTheme.magenta.opacity(0.3), AppTheme.purple.opacity(0.2)],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
            )
            .cornerRadius(16)
        }
        .buttonStyle(.plain)
        .disabled(isGenerating)
    }
}

// MARK: - Topic Tags View

struct TopicTagsView: View {
    let topicsJSON: String
    @State private var topics: [String] = []
    
    var body: some View {
        if !topics.isEmpty {
            VStack(alignment: .leading, spacing: 8) {
                Text("Topics")
                    .font(.caption)
                    .fontWeight(.semibold)
                    .foregroundStyle(.secondary)
                
                FlowLayout(spacing: 8) {
                    ForEach(topics, id: \.self) { topic in
                        Text(topic.capitalized)
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundStyle(.blue)
                            .padding(.horizontal, 12)
                            .padding(.vertical, 6)
                            .background(.blue.opacity(0.1))
                            .clipShape(Capsule())
                    }
                }
            }
            .task {
                parseTopics()
            }
        }
    }
    
    private func parseTopics() {
        do {
            let parsed = try [String].fromTopicsJSON(topicsJSON)
            // Limit to top 10 topics for display
            topics = Array(parsed.prefix(10))
        } catch {
            print("‚ö†Ô∏è [TopicTagsView] Failed to parse topics: \(error)")
        }
    }
}

// MARK: - Intelligence Engine View

struct IntelligenceEngineView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var activeEngine: EngineTier?
    @State private var availableEngines: [EngineTier] = []
    @State private var isLoading = true
    @State private var showUnavailableAlert = false
    @State private var selectedUnavailableTier: EngineTier?
    
    var body: some View {
        VStack(spacing: 0) {
            if isLoading {
                HStack {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Loading engines...")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                }
                .padding(.vertical, 8)
            } else {
                ForEach(EngineTier.privateTiers, id: \.self) { tier in
                    EngineRow(
                        tier: tier,
                        isActive: tier == activeEngine,
                        isAvailable: availableEngines.contains(tier)
                    )
                    .contentShape(Rectangle())
                    .onTapGesture {
                        selectEngine(tier)
                    }
                    
                    if tier != EngineTier.privateTiers.last {
                        Divider()
                            .padding(.leading, 48)
                    }
                }
            }
        }
        .task {
            await loadEngineStatus()
        }
        .onAppear {
            // Refresh engine status when view appears to catch changes
            Task {
                await loadEngineStatus()
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("EngineDidChange"))) { _ in
            // Refresh when engine changes from any view
            Task {
                await loadEngineStatus()
            }
        }
        .alert("Engine Unavailable", isPresented: $showUnavailableAlert) {
            Button("OK", role: .cancel) { }
        } message: {
            if let tier = selectedUnavailableTier {
                Text(unavailableMessage(for: tier))
            }
        }
    }
    
    private func loadEngineStatus() async {
        isLoading = true
        defer { isLoading = false }
        
        guard let summCoord = coordinator.summarizationCoordinator else {
            print("‚ö†Ô∏è [IntelligenceEngineView] No summarization coordinator available")
            return
        }
        
        // Get active engine
        activeEngine = await summCoord.getActiveEngine()
        
        // Get available engines
        availableEngines = await summCoord.getAvailableEngines()
    }
    
    private func selectEngine(_ tier: EngineTier) {
        // Check if already active
        if tier == activeEngine {
            return
        }
        
        // Check if available
        guard availableEngines.contains(tier) else {
            selectedUnavailableTier = tier
            showUnavailableAlert = true
            return
        }
        
        // Set preferred engine
        Task {
            guard let summCoord = coordinator.summarizationCoordinator else { return }
            
            await summCoord.setPreferredEngine(tier)
            await loadEngineStatus()  // Refresh UI
            
            // Notify other views to refresh
            NotificationCenter.default.post(name: NSNotification.Name("EngineDidChange"), object: nil)
            
            // Show success toast
            coordinator.showSuccess("Switched to \(tier.displayName)")
        }
    }
    
    private func unavailableMessage(for tier: EngineTier) -> String {
        switch tier {
        case .basic:
            return "Basic engine should always be available. Please restart the app."
        case .local:
            return "Local AI model needs to be downloaded. Go to Settings to download Phi-3.5."
        case .apple:
            return "Apple Intelligence requires iOS 18.1+ and compatible hardware. Your device or OS version doesn't support it yet."
        case .external:
            return "External API engine is not yet configured. You'll need to provide your own API key in a future update."
        }
    }
}

struct EngineRow: View {
    let tier: EngineTier
    let isActive: Bool
    let isAvailable: Bool
    
    var body: some View {
        HStack(spacing: 12) {
            // Icon
            Image(systemName: iconName)
                .font(.title2)
                .foregroundStyle(isAvailable ? iconColor : iconColor.opacity(0.3))
                .frame(width: 32, height: 32)
            
            // Name and description
            VStack(alignment: .leading, spacing: 4) {
                HStack(spacing: 8) {
                    Text(tier.displayName)
                        .font(.body)
                        .fontWeight(isActive ? .semibold : .regular)
                        .foregroundStyle(isAvailable ? .primary : .secondary)
                    
                    if isActive {
                        Text("Active")
                            .font(.caption)
                            .fontWeight(.semibold)
                            .foregroundStyle(.white)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 2)
                            .background(.green.gradient)
                            .clipShape(Capsule())
                    } else if isAvailable && !isActive {
                        Text("Available")
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundStyle(.green)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 2)
                            .background(.green.opacity(0.1))
                            .clipShape(Capsule())
                    } else if !isAvailable {
                        Text("Unavailable")
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundStyle(.secondary)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 2)
                            .background(.gray.opacity(0.08))
                            .clipShape(Capsule())
                    }
                }
                
                Text(tier.description)
                    .font(.caption)
                    .foregroundStyle(isAvailable ? .secondary : .tertiary)
                    .lineLimit(2)
                
                // Attributes
                HStack(spacing: 12) {
                    AttributeBadge(
                        icon: tier.isPrivacyPreserving ? "lock.fill" : "lock.open.fill",
                        text: tier.isPrivacyPreserving ? "Private" : "Cloud",
                        color: tier.isPrivacyPreserving ? .green : .orange,
                        isAvailable: isAvailable
                    )
                    
                    if tier.requiresInternet {
                        AttributeBadge(
                            icon: "wifi",
                            text: "Internet",
                            color: .blue,
                            isAvailable: isAvailable
                        )
                    }
                }
                .padding(.top, 4)
            }
            
            Spacer()
            
            // Chevron for available engines
            if isAvailable && !isActive {
                Image(systemName: "chevron.right")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
        }
        .padding(.vertical, 12)
        .padding(.horizontal, 12)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(isActive ? Color.green.opacity(0.12) : Color.clear)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .strokeBorder(isActive ? Color.green.opacity(0.3) : Color.clear, lineWidth: 2)
        )
        .contentShape(Rectangle())
        .opacity(isAvailable ? 1.0 : 0.5)
    }
    
    private var iconName: String {
        switch tier {
        case .basic: return "text.alignleft"
        case .local: return "cpu"
        case .apple: return "apple.logo"
        case .external: return "cloud"
        }
    }
    
    private var iconColor: Color {
        switch tier {
        case .basic: return .gray
        case .local: return .purple
        case .apple: return .blue
        case .external: return .orange
        }
    }
}

struct AttributeBadge: View {
    let icon: String
    let text: String
    let color: Color
    var isAvailable: Bool = true
    
    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: icon)
                .font(.system(size: 10))
            Text(text)
                .font(.system(size: 10, weight: .medium))
        }
        .foregroundStyle(isAvailable ? color : color.opacity(0.4))
        .padding(.horizontal, 6)
        .padding(.vertical, 3)
        .background(isAvailable ? color.opacity(0.1) : color.opacity(0.05))
        .clipShape(Capsule())
    }
}

// MARK: - External AI View

struct ExternalAIView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var activeEngine: EngineTier?
    @State private var availableEngines: [EngineTier] = []
    @State private var isLoading = true
    @State private var showConfigSheet = false
    
    var body: some View {
        VStack(spacing: 0) {
            if isLoading {
                HStack {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Loading...")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                }
                .padding(.vertical, 8)
            } else {
                EngineRow(
                    tier: .external,
                    isActive: activeEngine == .external,
                    isAvailable: availableEngines.contains(.external)
                )
                .contentShape(Rectangle())
                .onTapGesture {
                    selectEngine(.external)
                }
                
                Divider()
                    .padding(.leading, 48)
                
                // Configuration button
                Button {
                    showConfigSheet = true
                } label: {
                    HStack(spacing: 12) {
                        Image(systemName: "key.fill")
                            .font(.body)
                            .foregroundStyle(.orange)
                            .frame(width: 32, height: 32)
                        
                        Text("Configure API Keys")
                            .font(.subheadline)
                            .foregroundStyle(.primary)
                        
                        Spacer()
                        
                        Image(systemName: "chevron.right")
                            .font(.caption)
                            .foregroundStyle(.secondary)
                    }
                    .padding(.vertical, 8)
                }
            }
        }
        .task {
            await loadEngineStatus()
        }
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("EngineDidChange"))) { _ in
            // Refresh when engine changes from any view
            Task {
                await loadEngineStatus()
            }
        }
        .sheet(isPresented: $showConfigSheet, onDismiss: {
            // Refresh engine status after config sheet dismisses
            Task {
                await loadEngineStatus()
            }
        }) {
            ExternalAPIConfigView()
                .environmentObject(coordinator)
        }
    }
    
    private func loadEngineStatus() async {
        isLoading = true
        defer { isLoading = false }
        
        guard let summCoord = coordinator.summarizationCoordinator else { return }
        
        activeEngine = await summCoord.getActiveEngine()
        availableEngines = await summCoord.getAvailableEngines()
    }
    
    private func selectEngine(_ tier: EngineTier) {
        // Check if available
        guard availableEngines.contains(tier) else {
            showConfigSheet = true  // Open config if not available
            return
        }
        
        // Set preferred engine
        Task {
            guard let summCoord = coordinator.summarizationCoordinator else { return }
            
            await summCoord.setPreferredEngine(tier)
            await loadEngineStatus()
            
            // Notify other views to refresh
            NotificationCenter.default.post(name: NSNotification.Name("EngineDidChange"), object: nil)
            
            coordinator.showSuccess("Switched to \(tier.displayName)")
        }
    }
}

// MARK: - External API Configuration View

struct ExternalAPIConfigView: View {
    @Environment(\.dismiss) var dismiss
    @EnvironmentObject var coordinator: AppCoordinator
    
    @State private var selectedProvider: String = UserDefaults.standard.string(forKey: "externalAPIProvider") ?? "OpenAI"
    @State private var openaiKey: String = ""
    @State private var anthropicKey: String = ""
    @State private var isSaving = false
    @State private var isTesting = false
    @State private var testResult: String?
    @State private var testSuccess: Bool = false
    
    var body: some View {
        NavigationStack {
            Form {
                Section {
                    Picker("Provider", selection: $selectedProvider) {
                        Text("OpenAI").tag("OpenAI")
                        Text("Anthropic").tag("Anthropic")
                    }
                    .pickerStyle(.segmented)
                } header: {
                    Text("AI Provider")
                } footer: {
                    Text("Select which external AI service you want to use")
                }
                
                if selectedProvider == "OpenAI" {
                    Section {
                        SecureField("API Key", text: $openaiKey)
                            .textContentType(.password)
                            .autocapitalization(.none)
                            .autocorrectionDisabled()
                        
                        Button {
                            testAPIKey()
                        } label: {
                            HStack {
                                if isTesting {
                                    ProgressView()
                                        .scaleEffect(0.8)
                                    Text("Testing Key...")
                                } else {
                                    Label("Test API Key", systemImage: "checkmark.shield")
                                }
                            }
                        }
                        .disabled(openaiKey.isEmpty || isTesting)
                        
                        if let result = testResult {
                            Label(result, systemImage: testSuccess ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .font(.caption)
                                .foregroundStyle(testSuccess ? .green : .red)
                        }
                        
                        Link(destination: URL(string: "https://platform.openai.com/api-keys")!) {
                            Label("Get OpenAI API Key", systemImage: "arrow.up.right.square")
                        }
                    } header: {
                        Text("OpenAI Configuration")
                    } footer: {
                        Text("Your API key is stored securely in Keychain. Never shared with anyone.\n\nNote: Using OpenAI sends your transcript data to their servers. Standard API rates apply.")
                    }
                } else {
                    Section {
                        SecureField("API Key", text: $anthropicKey)
                            .textContentType(.password)
                            .autocapitalization(.none)
                            .autocorrectionDisabled()
                        
                        Button {
                            testAPIKey()
                        } label: {
                            HStack {
                                if isTesting {
                                    ProgressView()
                                        .scaleEffect(0.8)
                                    Text("Testing Key...")
                                } else {
                                    Label("Test API Key", systemImage: "checkmark.shield")
                                }
                            }
                        }
                        .disabled(anthropicKey.isEmpty || isTesting)
                        
                        if let result = testResult {
                            Label(result, systemImage: testSuccess ? "checkmark.circle.fill" : "xmark.circle.fill")
                                .font(.caption)
                                .foregroundStyle(testSuccess ? .green : .red)
                        }
                        
                        Link(destination: URL(string: "https://console.anthropic.com/account/keys")!) {
                            Label("Get Anthropic API Key", systemImage: "arrow.up.right.square")
                        }
                    } header: {
                        Text("Anthropic Configuration")
                    } footer: {
                        Text("Your API key is stored securely in Keychain. Never shared with anyone.\n\nNote: Using Anthropic sends your transcript data to their servers. Standard API rates apply.")
                    }
                }
                
                Section {
                    Button {
                        saveConfiguration()
                    } label: {
                        if isSaving {
                            HStack {
                                ProgressView()
                                    .scaleEffect(0.8)
                                Text("Saving...")
                            }
                        } else {
                            Text("Save Configuration")
                        }
                    }
                    .disabled(isSaving || (selectedProvider == "OpenAI" ? openaiKey.isEmpty : anthropicKey.isEmpty))
                }
            }
            .navigationTitle("External AI Setup")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
            .task {
                await loadExistingKeys()
            }
            .onChange(of: selectedProvider) { _, _ in
                testResult = nil  // Clear test result when switching providers
            }
            .onChange(of: openaiKey) { _, _ in
                testResult = nil  // Clear test result when key changes
            }
            .onChange(of: anthropicKey) { _, _ in
                testResult = nil  // Clear test result when key changes
            }
        }
    }
    
    private func loadExistingKeys() async {
        // Load existing keys from Keychain
        let keychain = KeychainManager.shared
        if let openaiExisting = await keychain.getAPIKey(for: .openai) {
            openaiKey = openaiExisting
        }
        if let anthropicExisting = await keychain.getAPIKey(for: .anthropic) {
            anthropicKey = anthropicExisting
        }
    }
    
    private func testAPIKey() {
        isTesting = true
        testResult = nil
        
        Task {
            do {
                // Simple test: check if key format looks valid
                let currentKey = selectedProvider == "OpenAI" ? openaiKey : anthropicKey
                
                if selectedProvider == "OpenAI" {
                    // OpenAI keys start with "sk-"
                    if currentKey.hasPrefix("sk-") && currentKey.count > 20 {
                        testSuccess = true
                        testResult = "Key format looks valid"
                    } else {
                        testSuccess = false
                        testResult = "Invalid key format (should start with 'sk-')"
                    }
                } else {
                    // Anthropic keys start with "sk-ant-"
                    if currentKey.hasPrefix("sk-ant-") && currentKey.count > 20 {
                        testSuccess = true
                        testResult = "Key format looks valid"
                    } else {
                        testSuccess = false
                        testResult = "Invalid key format (should start with 'sk-ant-')"
                    }
                }
                
                isTesting = false
            }
        }
    }
    
    private func saveConfiguration() {
        isSaving = true
        
        Task {
            let keychain = KeychainManager.shared
            
            if selectedProvider == "OpenAI" && !openaiKey.isEmpty {
                await keychain.setAPIKey(openaiKey, for: .openai)
                UserDefaults.standard.set("OpenAI", forKey: "externalAPIProvider")
            } else if selectedProvider == "Anthropic" && !anthropicKey.isEmpty {
                await keychain.setAPIKey(anthropicKey, for: .anthropic)
                UserDefaults.standard.set("Anthropic", forKey: "externalAPIProvider")
            }
            
            // Immediately refresh available engines so External AI becomes available
            if let summCoord = coordinator.summarizationCoordinator {
                _ = await summCoord.getAvailableEngines()
            }
            
            isSaving = false
            coordinator.showSuccess("API key saved! External AI is now available.")
            dismiss()
        }
    }
}


struct DetailRow: View {
    let icon: String
    let text: String
    
    var body: some View {
        HStack(spacing: 6) {
            Image(systemName: icon)
                .font(.caption2)
                .frame(width: 16)
            Text(text)
                .font(.caption)
        }
        .foregroundStyle(.secondary)
    }
}

// MARK: - Historical Data View

struct HistoricalDataView: View {
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var yearlyData: [(year: Int, sessionCount: Int, totalDuration: TimeInterval)] = []
    @State private var isLoading = true
    @State private var showDeleteAlert = false
    @State private var selectedYear: Int?
    
    var body: some View {
        List {
            if isLoading {
                Section {
                    HStack {
                        ProgressView()
                            .scaleEffect(0.8)
                        Text("Loading historical data...")
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                    }
                    .padding(.vertical, 8)
                }
            } else if yearlyData.isEmpty {
                Section {
                    ContentUnavailableView(
                        "No Historical Data",
                        systemImage: "clock.arrow.circlepath",
                        description: Text("Start recording to build your history.")
                    )
                }
            } else {
                Section {
                    Text("View insights from previous years or delete old data to free up space.")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                }
                
                ForEach(yearlyData, id: \.year) { data in
                    Section {
                        NavigationLink(destination: YearInsightsView(year: data.year)) {
                            HStack(spacing: 16) {
                                // Year icon
                                ZStack {
                                    RoundedRectangle(cornerRadius: 8)
                                        .fill(Color.blue.opacity(0.1))
                                        .frame(width: 50, height: 50)
                                    
                                    Text(String(data.year))
                                        .font(.headline)
                                        .foregroundStyle(.blue)
                                }
                                
                                // Stats
                                VStack(alignment: .leading, spacing: 4) {
                                    Text("\(data.year)")
                                        .font(.headline)
                                    
                                    HStack(spacing: 12) {
                                        Label("\(data.sessionCount)", systemImage: "mic.circle")
                                            .font(.caption)
                                            .foregroundStyle(.secondary)
                                        
                                        Label(formatDuration(data.totalDuration), systemImage: "timer")
                                            .font(.caption)
                                            .foregroundStyle(.secondary)
                                    }
                                }
                                
                                Spacer()
                            }
                        }
                        .swipeActions(edge: .trailing, allowsFullSwipe: false) {
                            Button(role: .destructive) {
                                selectedYear = data.year
                                showDeleteAlert = true
                            } label: {
                                Label("Delete", systemImage: "trash")
                            }
                        }
                    }
                }
            }
        }
        .navigationTitle("Historical Data")
        .navigationBarTitleDisplayMode(.inline)
        .task {
            await loadYearlyData()
        }
        .refreshable {
            await loadYearlyData()
        }
        .alert("Delete \(selectedYear ?? 0) Data?", isPresented: $showDeleteAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                if let year = selectedYear {
                    deleteYear(year)
                }
            }
        } message: {
            if let year = selectedYear {
                Text("This will permanently delete all recordings and data from \(year). This action cannot be undone.")
            }
        }
    }
    
    private func loadYearlyData() async {
        isLoading = true
        defer { isLoading = false }
        
        do {
            // Fetch all sessions
            let allSessions = try await coordinator.fetchRecentSessions(limit: 100000)
            
            // Group by year
            let calendar = Calendar.current
            var yearlyStats: [Int: (sessionCount: Int, totalDuration: TimeInterval)] = [:]
            
            for session in allSessions {
                let year = calendar.component(.year, from: session.startTime)
                let existing = yearlyStats[year] ?? (sessionCount: 0, totalDuration: 0)
                yearlyStats[year] = (
                    sessionCount: existing.sessionCount + 1,
                    totalDuration: existing.totalDuration + session.totalDuration
                )
            }
            
            // Convert to array and sort by year descending
            yearlyData = yearlyStats.map { (year: $0.key, sessionCount: $0.value.sessionCount, totalDuration: $0.value.totalDuration) }
                .sorted { $0.year > $1.year }
            
        } catch {
            print("‚ùå [HistoricalDataView] Failed to load yearly data: \(error)")
            coordinator.showError("Failed to load historical data")
        }
    }
    
    private func deleteYear(_ year: Int) {
        Task {
            do {
                // Fetch all sessions for this year
                let allSessions = try await coordinator.fetchRecentSessions(limit: 100000)
                let calendar = Calendar.current
                let sessionsToDelete = allSessions.filter { calendar.component(.year, from: $0.startTime) == year }
                
                // Delete each session using coordinator's delete method (handles cascading)
                for session in sessionsToDelete {
                    try? await coordinator.deleteSession(session.sessionId)
                }
                
                await MainActor.run {
                    coordinator.showSuccess("\(year) data deleted successfully")
                }
                
                // Reload data
                await loadYearlyData()
                
            } catch {
                await MainActor.run {
                    coordinator.showError("Failed to delete \(year) data: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let hours = Int(duration) / 3600
        let minutes = (Int(duration) % 3600) / 60
        
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        } else {
            return "\(minutes)m"
        }
    }
}

// MARK: - Year Insights View

struct YearInsightsView: View {
    let year: Int
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var sessions: [RecordingSession] = []
    @State private var sessionCount: Int = 0
    @State private var totalDuration: TimeInterval = 0
    @State private var totalWordCount: Int = 0
    @State private var isLoading = true
    @State private var isExporting = false
    @State private var showShareSheet = false
    @State private var exportURL: URL?
    @State private var showDeleteAlert = false
    @State private var monthlyBreakdown: [(monthNumber: Int, monthName: String, count: Int, duration: TimeInterval)] = []
    
    var body: some View {
        List {
            if isLoading {
                Section {
                    HStack {
                        ProgressView()
                            .scaleEffect(0.8)
                        Text("Loading \(String(year)) insights...")
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                    }
                    .padding(.vertical, 8)
                }
            } else if sessions.isEmpty {
                Section {
                    ContentUnavailableView(
                        "No Data for \(String(year))",
                        systemImage: "calendar.badge.exclamationmark",
                        description: Text("No recordings found for this year.")
                    )
                }
            } else {
                // Overview section
                Section {
                    VStack(alignment: .leading, spacing: 16) {
                        // Year header
                        HStack {
                            Text(String(year))
                                .font(.largeTitle)
                                .fontWeight(.bold)
                            
                            Spacer()
                            
                            Image(systemName: "calendar")
                                .font(.title)
                                .foregroundStyle(.blue)
                        }
                        
                        // Stats grid
                        LazyVGrid(columns: [
                            GridItem(.flexible()),
                            GridItem(.flexible()),
                            GridItem(.flexible())
                        ], spacing: 16) {
                            StatCard(
                                icon: "mic.circle.fill",
                                value: "\(sessionCount)",
                                label: "Sessions",
                                color: .blue
                            )
                            
                            StatCard(
                                icon: "timer",
                                value: formatDuration(totalDuration),
                                label: "Total Time",
                                color: .green
                            )
                            
                            StatCard(
                                icon: "text.word.spacing",
                                value: formatWordCount(totalWordCount),
                                label: "Words",
                                color: .purple
                            )
                        }
                    }
                    .padding(.vertical, 8)
                } header: {
                    Text("Overview")
                }
                
                // Monthly breakdown
                if !monthlyBreakdown.isEmpty {
                    Section {
                        ForEach(monthlyBreakdown, id: \.monthNumber) { item in
                            NavigationLink(destination: MonthInsightsView(year: year, month: item.monthNumber, monthName: item.monthName)) {
                                HStack {
                                    Text(item.monthName)
                                        .font(.subheadline)
                                    
                                    Spacer()
                                    
                                    Text("\(item.count) sessions")
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                    
                                    Text("‚Ä¢")
                                        .foregroundStyle(.secondary)
                                    
                                    Text(formatDuration(item.duration))
                                        .font(.caption)
                                        .foregroundStyle(.secondary)
                                }
                            }
                        }
                    } header: {
                        Text("Monthly Breakdown")
                    }
                }
                
                // Export section
                Section {
                    Button {
                        exportYearData()
                    } label: {
                        HStack {
                            Label("Export \(String(year)) Data", systemImage: "square.and.arrow.up")
                            
                            Spacer()
                            
                            if isExporting {
                                ProgressView()
                                    .scaleEffect(0.8)
                            }
                        }
                    }
                    .disabled(isExporting)
                } header: {
                    Text("Export")
                } footer: {
                    Text("Export all recordings and transcripts from \(String(year)) as a JSON file.")
                }
                
                // Delete section
                Section {
                    Button(role: .destructive) {
                        showDeleteAlert = true
                    } label: {
                        Label("Delete All \(String(year)) Data", systemImage: "trash")
                    }
                } header: {
                    Text("Danger Zone")
                } footer: {
                    Text("Permanently delete all recordings and data from \(String(year)). This cannot be undone.")
                }
            }
        }
        .navigationTitle(String(year))
        .navigationBarTitleDisplayMode(.inline)
        .task {
            await loadYearData()
        }
        .sheet(isPresented: $showShareSheet) {
            if let url = exportURL {
                ShareSheet(items: [url])
            }
        }
        .alert("Delete \(String(year)) Data?", isPresented: $showDeleteAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                deleteYearData()
            }
        } message: {
            Text("This will permanently delete all \(sessionCount) recordings from \(String(year)). This action cannot be undone.")
        }
    }
    
    private func loadYearData() async {
        isLoading = true
        defer { isLoading = false }
        
        let calendar = Calendar.current
        guard let startOfYear = calendar.date(from: DateComponents(year: year, month: 1, day: 1)),
              let endOfYear = calendar.date(from: DateComponents(year: year + 1, month: 1, day: 1)) else {
            return
        }
        
        do {
            // Fetch all sessions for this year
            let allSessions = try await coordinator.fetchRecentSessions(limit: 100000)
            sessions = allSessions.filter { $0.startTime >= startOfYear && $0.startTime < endOfYear }
            
            sessionCount = sessions.count
            totalDuration = sessions.reduce(0) { $0 + $1.totalDuration }
            
            // Calculate word count from database
            if let dbManager = coordinator.getDatabaseManager() {
                var wordCount = 0
                for session in sessions {
                    let count = try await dbManager.fetchSessionWordCount(sessionId: session.sessionId)
                    wordCount += count
                }
                totalWordCount = wordCount
            }
            
            // Calculate monthly breakdown
            var monthlyData: [Int: (count: Int, duration: TimeInterval)] = [:]
            for session in sessions {
                let month = calendar.component(.month, from: session.startTime)
                let existing = monthlyData[month] ?? (count: 0, duration: 0)
                monthlyData[month] = (count: existing.count + 1, duration: existing.duration + session.totalDuration)
            }
            
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "MMMM"
            
            monthlyBreakdown = monthlyData.keys.sorted().compactMap { month -> (monthNumber: Int, monthName: String, count: Int, duration: TimeInterval)? in
                guard let data = monthlyData[month],
                      let date = calendar.date(from: DateComponents(year: year, month: month, day: 1)) else {
                    return nil
                }
                return (monthNumber: month, monthName: dateFormatter.string(from: date), count: data.count, duration: data.duration)
            }
            
        } catch {
            print("‚ùå [YearInsightsView] Failed to load year data: \(error)")
            coordinator.showError("Failed to load year data")
        }
    }
    
    private func exportYearData() {
        isExporting = true
        
        Task {
            do {
                guard let dbManager = coordinator.getDatabaseManager() else {
                    throw NSError(domain: "YearInsightsView", code: 1, userInfo: [NSLocalizedDescriptionKey: "Database not available"])
                }
                
                // Build export data for this year
                var exportData: [[String: Any]] = []
                
                for session in sessions {
                    // Fetch chunks for this session
                    let chunks = try await dbManager.fetchChunksBySession(sessionId: session.sessionId)
                    
                    var sessionData: [String: Any] = [
                        "sessionId": session.sessionId.uuidString,
                        "startTime": ISO8601DateFormatter().string(from: session.startTime),
                        "duration": session.totalDuration,
                        "chunkCount": chunks.count
                    ]
                    
                    // Fetch transcripts for each chunk
                    var transcripts: [[String: Any]] = []
                    for chunk in chunks {
                        let segments = try await dbManager.fetchTranscriptSegments(audioChunkID: chunk.id)
                        let text = segments.map { $0.text }.joined(separator: " ")
                        if !text.isEmpty {
                            transcripts.append([
                                "chunkIndex": chunk.chunkIndex,
                                "text": text,
                                "wordCount": segments.reduce(0) { $0 + $1.wordCount }
                            ])
                        }
                    }
                    sessionData["transcripts"] = transcripts
                    
                    // Fetch session summary if available
                    if let summary = try await dbManager.fetchSummaryForSession(sessionId: session.sessionId) {
                        sessionData["summary"] = summary.text
                    }
                    
                    exportData.append(sessionData)
                }
                
                // Create export JSON
                let exportDict: [String: Any] = [
                    "exportDate": ISO8601DateFormatter().string(from: Date()),
                    "year": year,
                    "sessionCount": sessionCount,
                    "totalDurationSeconds": totalDuration,
                    "totalWordCount": totalWordCount,
                    "sessions": exportData
                ]
                
                let jsonData = try JSONSerialization.data(withJSONObject: exportDict, options: [.prettyPrinted, .sortedKeys])
                
                let filename = "lifewrapped-\(year)-export.json"
                let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent(filename)
                try jsonData.write(to: tempURL)
                
                await MainActor.run {
                    exportURL = tempURL
                    showShareSheet = true
                    isExporting = false
                    coordinator.showSuccess("Exported \(sessionCount) sessions from \(year)")
                }
                
            } catch {
                await MainActor.run {
                    isExporting = false
                    coordinator.showError("Export failed: \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func deleteYearData() {
        Task {
            for session in sessions {
                try? await coordinator.deleteSession(session.sessionId)
            }
            
            await MainActor.run {
                coordinator.showSuccess("\(year) data deleted successfully")
            }
            
            // Reload to show empty state
            await loadYearData()
        }
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let hours = Int(duration) / 3600
        let minutes = (Int(duration) % 3600) / 60
        
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        } else {
            return "\(minutes)m"
        }
    }
    
    private func formatWordCount(_ count: Int) -> String {
        if count >= 1000 {
            let formatted = Double(count) / 1000.0
            return String(format: "%.1fK", formatted)
        }
        return "\(count)"
    }
}

// MARK: - Stat Card Component

struct StatCard: View {
    let icon: String
    let value: String
    let label: String
    let color: Color
    
    var body: some View {
        VStack(spacing: 6) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundStyle(color)
            
            Text(value)
                .font(.headline)
                .fontWeight(.bold)
            
            Text(label)
                .font(.caption2)
                .foregroundStyle(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 12)
        .background(color.opacity(0.1))
        .clipShape(RoundedRectangle(cornerRadius: 10))
    }
}

// MARK: - Month Insights View

struct MonthInsightsView: View {
    let year: Int
    let month: Int
    let monthName: String
    
    @EnvironmentObject var coordinator: AppCoordinator
    @State private var sessions: [RecordingSession] = []
    @State private var isLoading = true
    @State private var totalDuration: TimeInterval = 0
    @State private var totalWordCount: Int = 0
    
    var body: some View {
        List {
            if isLoading {
                Section {
                    HStack {
                        ProgressView()
                            .scaleEffect(0.8)
                        Text("Loading \(monthName) sessions...")
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                    }
                    .padding(.vertical, 8)
                }
            } else if sessions.isEmpty {
                Section {
                    ContentUnavailableView(
                        "No Sessions",
                        systemImage: "calendar.badge.exclamationmark",
                        description: Text("No recordings found for \(monthName) \(String(year)).")
                    )
                }
            } else {
                // Stats section
                Section {
                    HStack(spacing: 20) {
                        StatCard(
                            icon: "mic.circle.fill",
                            value: "\(sessions.count)",
                            label: "Sessions",
                            color: .blue
                        )
                        
                        StatCard(
                            icon: "timer",
                            value: formatDuration(totalDuration),
                            label: "Total Time",
                            color: .green
                        )
                        
                        StatCard(
                            icon: "text.word.spacing",
                            value: formatWordCount(totalWordCount),
                            label: "Words",
                            color: .purple
                        )
                    }
                    .listRowInsets(EdgeInsets())
                    .listRowBackground(Color.clear)
                    .padding(.vertical, 8)
                } header: {
                    Text("Overview")
                }
                
                // Sessions list
                Section {
                    ForEach(sessions, id: \.sessionId) { session in
                        NavigationLink(destination: SessionDetailView(session: session)) {
                            SessionRowView(session: session)
                        }
                    }
                } header: {
                    Text("Sessions")
                }
            }
        }
        .navigationTitle("\(monthName) \(String(year))")
        .navigationBarTitleDisplayMode(.inline)
        .task {
            await loadMonthData()
        }
    }
    
    private func loadMonthData() async {
        isLoading = true
        defer { isLoading = false }
        
        let calendar = Calendar.current
        guard let startOfMonth = calendar.date(from: DateComponents(year: year, month: month, day: 1)),
              let endOfMonth = calendar.date(byAdding: .month, value: 1, to: startOfMonth) else {
            return
        }
        
        do {
            // Fetch all sessions and filter by month
            let allSessions = try await coordinator.fetchRecentSessions(limit: 100000)
            sessions = allSessions.filter { $0.startTime >= startOfMonth && $0.startTime < endOfMonth }
                .sorted { $0.startTime > $1.startTime }
            
            totalDuration = sessions.reduce(0) { $0 + $1.totalDuration }
            
            // Calculate word count
            if let dbManager = coordinator.getDatabaseManager() {
                var wordCount = 0
                for session in sessions {
                    let count = try await dbManager.fetchSessionWordCount(sessionId: session.sessionId)
                    wordCount += count
                }
                totalWordCount = wordCount
            }
            
        } catch {
            print("‚ùå [MonthInsightsView] Failed to load month data: \(error)")
            coordinator.showError("Failed to load month data")
        }
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let hours = Int(duration) / 3600
        let minutes = (Int(duration) % 3600) / 60
        
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        } else {
            return "\(minutes)m"
        }
    }
    
    private func formatWordCount(_ count: Int) -> String {
        if count >= 1000 {
            let formatted = Double(count) / 1000.0
            return String(format: "%.1fK", formatted)
        }
        return "\(count)"
    }
}

// MARK: - Session Row View for Month

struct SessionRowView: View {
    let session: RecordingSession
    
    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text(session.startTime, style: .date)
                .font(.subheadline)
                .fontWeight(.medium)
            
            HStack(spacing: 12) {
                Label(formatTime(session.startTime), systemImage: "clock")
                    .font(.caption)
                    .foregroundStyle(.secondary)
                
                Label(formatDuration(session.totalDuration), systemImage: "timer")
                    .font(.caption)
                    .foregroundStyle(.secondary)
            }
        }
        .padding(.vertical, 4)
    }
    
    private func formatTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let minutes = Int(duration) / 60
        let seconds = Int(duration) % 60
        
        if minutes > 0 {
            return "\(minutes)m \(seconds)s"
        } else {
            return "\(seconds)s"
        }
    }
}

// MARK: - Array Extension

// MARK: - Preview

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
            .environmentObject(AppCoordinator.previewInstance())
    }
}
